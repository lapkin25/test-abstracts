
<!DOCTYPE html>


<html lang="en" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Логика в программировании &#8212; Элементы математики</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.5.1/css/all.min.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.1/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.1/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.1/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/styles/sphinx-book-theme.css?v=384b581d" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
    <link rel="stylesheet" type="text/css" href="_static/../styles/editor_styles.css?v=14e1f340" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae" />
  <script src="_static/vendor/fontawesome/6.5.1/js/all.min.js?digest=8d27b9dea8ad943066ae"></script>

    <script src="_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="_static/copybutton.js?v=f281be69"></script>
    <script src="_static/scripts/sphinx-book-theme.js?v=efea14e4"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js?v=36754332"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'logic-and-programming';</script>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.25.0/full/pyodide.js"></script>
    <script src="_static/../js/pyodide_api.js?v=56641602"></script>
    <script src="_static/../js/editor_api.js?v=f0b4a606"></script>
    <script src="_static/../js/editor.bundle.js?v=1047e269"></script>
    <script src="_static/tests/ls_task1.js?v=115f8710"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Развлечения" href="entertainment.html" />
    <link rel="prev" title="Логика и вычисления" href="logic-computation.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a id="pst-skip-link" class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <header class="bd-header navbar navbar-expand-lg bd-navbar">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="_static/logo.png" class="logo__image only-light" alt="Элементы математики - Home"/>
    <script>document.write(`<img src="_static/logo.png" class="logo__image only-dark" alt="Элементы математики - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="intro.html">
                    Элементы математики
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="linalg.html">Линейная алгебра</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="linear-spaces.html">Линейные пространства и линейные отображения</a></li>
<li class="toctree-l2"><a class="reference internal" href="linear-mappings.html">Линейные отображения</a></li>
<li class="toctree-l2"><a class="reference internal" href="matrix-mult.html">Умножение матриц</a></li>
<li class="toctree-l2"><a class="reference internal" href="ls.html">Аппроксимация. Метод наименьших квадратов</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="statistics.html">Статистика</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="linear-regression.html">Линейная регрессия</a></li>
<li class="toctree-l2"><a class="reference internal" href="regression_use.html">Использование линейной регрессии</a></li>
<li class="toctree-l2"><a class="reference internal" href="naive-Bayes.html">Наивный байесовский классификатор</a></li>
<li class="toctree-l2"><a class="reference internal" href="monte_carlo.html">Метод Монте-Карло</a></li>
<li class="toctree-l2"><a class="reference internal" href="confusion.html">Матрица неточности</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="algorithms.html">Алгоритмы</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-3"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="algo-intro1.html">Начало тренировок</a></li>
<li class="toctree-l2"><a class="reference internal" href="algo-seq-sets.html">Последовательности и множества</a></li>
<li class="toctree-l2"><a class="reference internal" href="algo-trees-graphs.html">Деревья и графы</a></li>
</ul>
</li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="logic-computation.html">Логика и вычисления</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-4"><i class="fa-solid fa-chevron-down"></i></label><ul class="current">
<li class="toctree-l2 current active"><a class="current reference internal" href="#">Логика в программировании</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="entertainment.html">Развлечения</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-5"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="math_cards.html">Математические открытки</a></li>
<li class="toctree-l2"><a class="reference internal" href="math_songs.html">Математические песни</a></li>
</ul>
</li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/lapkin25/test-abstracts" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/lapkin25/test-abstracts/issues/new?title=Issue%20on%20page%20%2Flogic-and-programming.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/logic-and-programming.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Логика в программировании</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">Введение</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">Формализация логики</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">Вычислительные модели и теории</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">Вычисления в истории цивилизации</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">Рекурсивные функции</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">Лямбда-исчисление</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">Машины Тьюринга</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">Логика в программировании</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">Заключение</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="id1">
<h1>Логика в программировании<a class="headerlink" href="#id1" title="Link to this heading">#</a></h1>
<p><em>Конспект статьи <a class="reference external" href="https://doi.org/10.1007/978-981-96-4656-2_2">Liu et al. - From logic to programming (2025)</a></em></p>
<p>Математическая логика - это естественное основание компьютерных наук и компьютерных систем. Вычислительные модели и языки программирования представляют собой формально-логические системы. Выполнение программ следует рассматривать в свете логических выводов.</p>
<p>Статья выявляет, как в процессе возникновения фундаментальных проблем в логике, математике и теории вычислений образовалась современная наука и технологии. Наряду с философскими следствиями теоремы Гёделя о неполноте, языки формальных логических систем, как и построение доказательства теорем с помощью вывода из аксиом, приводят к неполноте возможностей логического выражения и умозаключений по сравнению с человеческой интуицией, восприятием и сознанием. Пожалуй, это фундаментальные факторы, отличающие человеческий интеллект от машинного (т.е. ИИ).</p>
<section id="id2">
<h2>Введение<a class="headerlink" href="#id2" title="Link to this heading">#</a></h2>
<p>Развитие логики и вычислений в нашей цивилизации отражает эволюцию того, как мы мыслим, как происходит обработка информации и решение проблем. От древних философских изысканий к современным технологическим инновациям, логика и вычисления отражают интеллектуальное, технологическое и социальное развитие.</p>
<p>Эта статья представляет обзор следующих направлений.</p>
<ul class="simple">
<li><p><strong>Истоки и формализация логики.</strong> Обсуждается логика, основанная на естественном языке. Естественный язык имеет свои ограничения. Аристотель сформулировал формальную логику, включающую силлогизмы. Обсуждаются принципы символической логики. Возникновение математической логики после работ Гильберта и др. по формальным языкам, системам доказательств и моделям. В дальнейшем возникла метатеория формально-логических систем, она затронула такие фундаментальные вопросы, как: непротиворечивость логических систем, корректность, адекватность, полнота и разрешимость. Мы обсудим теорему Гёделя о неполноте и ее философские следствия, включая творческие способности человека и машины.</p></li>
<li><p><strong>Возникновение современных моделей вычислений.</strong> Развитие современных вычислительных моделей последовало за ответом на программу Гильберта после доказательства теорем Гёделя. С развитием нашей цивилизации стали развиваться средства вычислений. Ранняя история вычислительных приборов включает изобретение абака и пр. в работах Паскаля, Лейбница и Бэббиджа. Определение рекурсивных функций было дано Гёделем, что стало “поворотной точкой” между логикой и вычислениями. Впоследствии в работах Аккермана, Клини и Чёрча сформировалась теория вычислимости. Разработанное Чёрчем λ-исчисление продемонстрировало, что сформулированная Гильбертом и Аккерманом проблема разрешимости не может быть решена, что приводит к понятию вычислимости. Примерно в то же время Тьюринг предложил машины Тьюринга, чтобы лучше прояснить понятие вычислимой функции. И хотя главной целью Тьюринга было показать, что проблема разрешимости Гильберта и Аккермана не может быть решена, его работы сформировали перспективы для проведения вычислений. В дальнейшем с помощью тезиса Чёрча и тезиса Тьюринга-Чёрча было доказано, что три модели - рекурсивные функции, λ-исчисление и машины Тьюринга - эквивалентны в своей вычислительной способности. Вместе эти модели стали теоретическим основанием современных цифровых вычислений, хотя изначально их цель была в том, чтобы найти ответы на вопросы, поставленные в программе Гильберта. Теоретические модели вычислений совершили революцию в области вычислений. Однако все они имеют логическую природу и поэтому обладают ограничениями, характерными для формальных систем, как следует из теорем Гёделя и теорем о неразрешимости Чёрча и Тьюринга. Эти ограничения касаются глубоких вопросов о человеческом и искусственном интеллекте, способности ИИ к созданию инноваций, логическом выводе, планировании и объяснимости систем искусственного интеллекта.</p></li>
<li><p><strong>Появление цифровых компьютеров и теории языков программирования.</strong> Середина XX века ознаменовалась созданием программируемых компьютеров, начиная с машин таких, как ENIAC и Colossus. Архитектура фон Неймана остается основой современных компьютеров, делая возможной автоматизацию сложных вычислений, что привело к цифровой революции. С тех пор произошло существенное развитие языков программирования и инструментальных платформ для разработки, благодаря эволюции программных абстракций. Сначала произошел прогресс от машинных языков к символическим ассемблерам и затем к языкам программирования высокого уровня с компиляторами и интерпретаторами; далее возникли абстрактные типы данных, модульность, объектно-ориентированное программирование и т.д. Следовательно, проектирование и реализация языков программирования стали центральной частью компьютерных наук и системной инженерии. Мы обсудим естественную взаимосвязь между математической логикой, моделями вычислений и языками программирования. Языки программирования - это формальные языки, их синтаксис и семантика определяется аналогично языкам формальной логики. Эта взаимосвязь подтверждает мысль, что всякое вычисление можно представить как построение доказательства, что было показано Тьюрингом и Постом. Чтобы это проиллюстрировать, мы введем минимальный (но полный по Тьюрингу) язык программирования вместе с операциональной семантикой языка, денотационной семантикой и аксиоматической семантикой в логике Хоара. Мы обсудим взаимосвязь между этими семантическими моделями и то, как они соотносятся к алгебраической семантикой.</p></li>
</ul>
<p>В заключении обсуждается, как разрабатывать основанные на логике теории для сегодняшних компьютерных систем. Новейшие разработки в аппаратном обеспечении, такие как разработка транзисторов и эволюция языков программирования высокого уровня, сделали возможным повсеместное распространение вычислительных систем в обществе. От ранних компьютеров размером с комнату до сегодняшних компактных и взаимосвязанных устройств, вычислительные мощности расширились до возможности поддержки глобальных коммуникаций, коммерции и инноваций в области искусственного интеллекта. Сейчас сообщество столкнулось с новыми проблемами, которые связаны с разработкой теорий, основанных на логике, созданием методов и инструментов для понимания и развития этих систем.</p>
</section>
<section id="id3">
<h2>Формализация логики<a class="headerlink" href="#id3" title="Link to this heading">#</a></h2>
<p>Логика - учение об искусстве, теории, методах, способах и инструментах для рассуждения и принятия решений. Прежде всего, это относится к определению правильности понятий, а также истинности или ложности высказываний.</p>
<p>Термин “логическая система” обычно относится к специальной системе, состоящей из правил формулирования, рассуждения или доказательства утверждений.</p>
<p>Логика охватывает множество областей, от науки, инженерии и технологии до лингвистики, гуманитарных и социальных наук, права. Например, определяя понятие, необходимо уточнить и оценить его правильность, чтобы удостовериться в его осмысленности. Делая утверждение или суждение, всегда ставится вопрос о его логичности.</p>
<p><strong>Зачем нужна логика?</strong> Всякая система: инженерное устройство, социальная организация или отдельный человек - ведет себя согласно определенной логике. Последовательность суждений обеспечивает гармоничное и правильное функционирование при проектировании, использовании или интеграции любой системы. Прикладные концепции понятности (объяснимости), достоверности и надежности берут свое начало в логике. Логическая непротиворечивости, целостность и полнота упомянутых систем имеют решающее значение для их стабильности, эффективности и надежности.</p>
<p><strong>Формализация логики.</strong> Древние участники дебатов и философы изначально пользовались логикой в рамках естественных языков. Неточная структура естественного языка приводит к неоднозначности трактовок, что служит причиной парадоксов. Китайский парадокс: “Если белые лошади - это лошади, то черные лошади - это лошади. Значит, белые лошади - это черные лошади.”</p>
<p>При отсутствии логической структуры сложно избежать в рамках высказывания ссылок на само же это высказывание. Парадокс лжеца: “это утверждение ложно”. Парадокс брадобрея, или парадокс Рассела: противоречие с возможностью определить любое множество как “коллекцию различимых объектов”. Если определить множество всех множеств, не содержащих самого себя в качестве элемента, <span class="math notranslate nohighlight">\(Y = \{S \colon S \notin S\}\)</span>, а потом спросить, принадлежит ли это множество самому себе, т.е. <span class="math notranslate nohighlight">\(Y \in Y\)</span>, приходим к противоречию.</p>
<p>Эти и прочие парадоксы приводят к проблеме формулирования процессов рассуждений и проверки их правильности. Как сказано выше, в рамках естественного языка это затруднительно. Поэтому необходима более структурированная и формальная система, чтобы исключить противоречия и непоследовательность в рассуждениях.</p>
<p><em>Парадокс Рассела и аксиоматизация теории множеств.</em> Парадокс Рассела стал причиной кризиса в теории множеств как основании математики. За ним последовали многочисленные усилия, направленные на то, чтобы обойти этот парадокс.</p>
<p>Рассел разработал теорию типов, которая предлагает рассматривать иерархическую структуру, состоящую из множеств, определенных на разных слоях. Множество, находящееся на некотором слое, не может быть определено через множества, находящиеся на более нижних слоях. Стоит отметить, что архитектуры многих инженерных систем построены по аналогичному иерархическому принципу.</p>
<p>Другой подход известен как теория множеств Цермело. Она предшествовало современной теории Цермело-Френкеля (ZF) и ее расширениям, таким, как теория множеств Неймана-Бернайса-Гёделя (NBG). На сегодняшний день, в сочетании с аксиомой выбора (аббревиатура ZFC), теория множеств ZF служит стандартной формой аксиоматической теории множеств. Эта теория рассматривается как наиболее важная составляющая оснований математики.</p>
<p><em>Программа Гильберта и теорема Гёделя о неполноте.</em> В конце XIX - начале XX в. Гильберт привлек значительное внимание к основаниям математики. Сосредоточившись на геометрических аксиомах, Гильберт высказал идею, чтобы свести вопрос о непротиворечивости геометрии к непротиворечивости анализа, интерпретируя геометрическую систему в рамках действительной плоскости. Однако доказательство непротиворечивости его аксиоматизации столкнулось с значительными трудностями ввиду допущений анализа Дедекинда, примерно как и с парадоксом Рассела в теории множеств.</p>
<p>Гильберт подчеркивал важность доказательств непроворечивости аксиоматических систем:
“Главное требование теории аксиом должно идти дальше (чем просто избегать известных парадоксов), а именно аксиомы должны давать возможность показать, что в каждой области знания противоречия, основанные на лежащей в ее основе системе аксиом, абсолютно невозможны.”</p>
<p>Помимо вопроса о непротиворечивости, Гильберт интересовался и другими проблемами аксиоматизации, такими, как “разрешимость всякого математического вопроса”.</p>
<p>Сформулированная Гильбертом программа предназначалась для разрешения фундаментального кризиса в математике того времени. Вот цели программы Гильберта:</p>
<ol class="arabic simple">
<li><p>Формальная логическая система для математики: все математические утверждения следует выражать на точном формальном языке и действовать с ними в соответствии с корректно определенными правилами.</p></li>
<li><p>Полнота: доказательство, что все истинные математические утверждения можно вывести в рамках введенного формализма.</p></li>
<li><p>Непротиворечивость: доказательство, что в рамках формализма не возникает противоречий. В идеале это доказательство должно использовать только “конечностные” рассуждения о конечных математических объектах.</p></li>
<li><p>Консервативность: доказательство, что всякий результат о “реальных объектах”, полученный с помощью рассуждений над “идеальными объектами” (такими, как несчетные множества) также можно доказать, не прибегая к идеальным объектам.</p></li>
<li><p>Разрешимость: должен существовать алгоритм, способный определить истинность либо ложность математических утверждений.</p></li>
</ol>
<p>Однако в 1930 г. Гёдель показал, что большая часть целей этой программы недостижима. Это вытекает из теорем Гёделя о неполноте и результатов Чёрча и Тьюринга о неразрешимости. Теорема Гёделя дает понять, что всякая непротиворечивая  логическая система, с помощью которой можно выразить арифметику, будет неполной; всегда будут истинные утверждения в рамках этой системы, которые не могут быть доказаны. Несуществование алгоритма, выясняющего истинность произвольного математического утверждения, показано Чёрчем и Тьюрингом - таким образом, проблема разрешимости Гильберта-Аккермана (известная также как Entscheidungsproblem) не имеет решения.</p>
<p><em>Теория вычислимости.</em> Хотя программа Гильберта оказалась невыполнимой, многие исследования в математической логике и математике являются продолжением этой программы. Стремление формализовать математику играло важную роль в обходе многочисленных математических парадоксов и помогло создать новые области математики и науки.</p>
<p>Влияние формальной логики и ее формализации выходит далеко за рамки самой математики; благодаря логике возникли и развились компьютерные науки. Доказательство Гёделем его первой теоремы о неполноте ознаменовало начало развития теории рекурсивных функций. Теория рекурсивных функций и доказательство теоремы о неполноте сильно повлияли на развитие λ-исчисления и определение машин Тьюринга, которые изначально предназначались для того, чтобы показать, что проблема разрешимости Гильберта-Аккермана не имеет решения. Теория рекурсивных функций, λ-исчисление и теория машин Тьюринга формируют современную теорию вычислимости.</p>
<p><em>Компьютерные науки и программная инженерия.</em> Модель компьютера с хранимой программой, которая носит название фон-неймановской архитектуры, была предложена фон Нейманом в 1945 г. Она была основана на модели универсальной машины Тьюринга. Эта концепция открыла дорогу к разработке языков программирования и абстракций программного обеспечения, и формальная логика здесь - твердое основание.</p>
<p><strong>Ранняя форма формальной логики.</strong> У естественного языка есть свои ограничения, затрудняющие правильные рассуждения и планирование. Естественного языка недостаточно для строгого мышления, с его помощью затруднительно сформулировать процессы рассуждений и определить правильность рассуждений. Развитие формальной логики началось с основополагающей работы Аристотеля. Мыслитель предложил три ключевые идеи, на которых построена формальная логика. Его идеи оказали значимое влияние на логику, философию, современную науку и технику.</p>
<p>Одна из идей Аристотеля - отделить форму рассуждений от их содержания. Это значит, что правильность рассуждений определяется прежде всего их формой, а не конкретным содержанием предпосылок. Это ранняя идея формализации логических выводов, в которых рассуждения касаются только структуры выводов. Другими словами, корректность логических рассуждений зависит только от формы выводов и не зависит от содержания предмета.</p>
<p><em>Явные посылки в рассуждениях.</em> Аристотель подчеркивал, что для того чтобы рассуждение было правильным, все посылки должны быть указаны явно. Это требование гарантирует ясность и строгость логических выводов. При любом пропуске посылок рассуждения будут неполными, или это приведет к скрытым допущениям, что вводит неясность выводов и подрывает их логическую правильность.</p>
<p><em>Искусственные символы.</em> Аристотель объяснил ограничения естественного языка и предложил использовать искусственные символы. Формальные языки, как в современной формальной логике, он изобретать не стал. Аристотель использовал греческие буквы в своих обозначениях.</p>
<p>В своей работе “Первая аналитика” Аристотель ввел понятие силлогизма. Впоследствии на принципы Аристотеля опирался логик Фреге в своей книге “Язык формул для чистой мысли, основанный на арифметике”. Подход Аристотеля к логике отражает его философию в целом, известную как “Метафизика”. В философии Аристотеля все вещи представляются как единство формы и содержания.</p>
<ul class="simple">
<li><p>Форма: Структура и организация объекта. Определяет первичную функцию, назначение и сходство между объектами одного типа.</p></li>
<li><p>Содержание: Разные части, из которых состоит объект. Определяет конкретные свойства объекта, характеристики и индивидуальность.</p></li>
</ul>
<p>Для понимания природы любого объекта нужно учесть как форму, так и содержание. Форма дает организационную структуру, а содержание отражает отдельные характеристики объекта. Это соотношение между формой и содержанием имеет далеко идущие следствия за рамками логики и математики (где важны изоморфизмы и гомоморфизмы между алгебраическими структурами), расширяясь до гуманитарных и естественных наук, техники. В этих дисциплинах организационная структура, системная архитектура и алгебраические структуры часто проявляют гомоморфизмы и изоморфизмы, отражая единство формы и содержания. Эти идеи имеют фундаментальное значение в проектировании целостных и эффективных систем, относясь будь то к человеческим организациям, научным моделям или техническим структурам.</p>
<p><em>Рассуждения посредством аристотелевских силлогизмов.</em> Аристотель, основатель формальной логики, ввел силлогизмы как способ формулирования рассуждений в рамках логических выводов. По Аристотелю, силлогизм - это “рассуждение, в котором предполагаются определенные вещи, причем из них с необходимостью вытекает нечто отличное от предполагаемых вещей, потому что эти вещи таковы”.</p>
<p>Центральная часть этого определения - “с необходимостью вытекает”. Это соответствует современному понятию логического следствия: мы говорим, что <span class="math notranslate nohighlight">\(X\)</span> с необходимостью вытекает из <span class="math notranslate nohighlight">\(Y\)</span> и <span class="math notranslate nohighlight">\(Z\)</span>, если ситуация, в которой <span class="math notranslate nohighlight">\(X\)</span> ложна при том, что <span class="math notranslate nohighlight">\(Y\)</span> и <span class="math notranslate nohighlight">\(Z\)</span> одновременно истинны, является невозможной. Такой вывод оказывается правильным по своей форме.</p>
<p>В формальной логике предполагаемые вещи называются посылками (т.е. <span class="math notranslate nohighlight">\(Y\)</span> и <span class="math notranslate nohighlight">\(Z\)</span>), а другая вещь, с необходимостью вытекающая из посылок, - это заключение. Чтобы рассуждение было правильным, посылки и заключение должны быть связаны подходящим образом. Вывод по силлогизму состоит из главной посылки, побочной посылки и заключения, которое с необходимостью следует из посылок. Вот пример вывода по силлогизму:</p>
<p><u>Главная посылка</u>: Все люди смертны.</p>
<p><u>Побочная посылка</u>: Цинь Шихуанди - человек.</p>
<p><u>Заключение</u>: Следовательно, Цинь Шихуанди смертен.</p>
<p>Это рассуждение верно, потому что заключение логически следует из посылок, независимо от конкретного содержания. Именно форма вывода, в которой две посылки приводят к заключению, обеспечивает правильность рассуждений. Пример неправильного силлогизма:</p>
<p><u>Главная посылка</u>: Некоторые музыканты - пианисты.</p>
<p><u>Побочная посылка</u>: Лан Лан - музыкант.</p>
<p><u>Заключение</u>: Следовательно, Лан Лан - пианист.</p>
<p>Вывод неправилен, поскольку только некоторые, но не обязательно все, музыканты - пианисты. Поэтому могут существовать примеры музыкантов, которые не являются пианистами. Даже хотя Лан Лан - известный китайский пианист, такой вывод не следует с необходимостью из этих двух посылок.</p>
<p>Назовем сказуемое заключения основной частью вывода (обозначим ее через <span class="math notranslate nohighlight">\(P\)</span>), сказуемое побочной посылки - это средняя часть вывода (обозначим ее через <span class="math notranslate nohighlight">\(M\)</span>), и подлежащее заключения - это побочная часть вывода (обозначим ее через <span class="math notranslate nohighlight">\(S\)</span>). Средняя часть (M) входит в обе посылки, но не входит в заключение, она служит связкой между подлежащим и сказуемым. Стандартный силлогизм можно сформулировать с помощью символов так:</p>
<p><u>Главная посылка</u>: Все <span class="math notranslate nohighlight">\(M\)</span> суть <span class="math notranslate nohighlight">\(P\)</span>.</p>
<p><u>Побочная посылка</u>: <span class="math notranslate nohighlight">\(S\)</span> суть <span class="math notranslate nohighlight">\(M\)</span>.</p>
<p><u>Заключение</u>: <span class="math notranslate nohighlight">\(S\)</span> суть <span class="math notranslate nohighlight">\(P\)</span>.</p>
<p>Всего существует четыре различных конфигурации: <span class="math notranslate nohighlight">\((MP, SM, SP)\)</span>, <span class="math notranslate nohighlight">\((PM, SM, SP)\)</span>, <span class="math notranslate nohighlight">\((MP, MS, SP)\)</span>, <span class="math notranslate nohighlight">\((PM, MS, SP)\)</span>, причем слова “все” и “некоторые” (возможно, с частицей “не”) относятся к <span class="math notranslate nohighlight">\(P, M, S\)</span>. Всего получаем 256 типов силлогизмов. Известно, что лишь <a class="reference external" href="https://en.wikipedia.org/wiki/List_of_valid_argument_forms">24 из них правильны</a>.</p>
<p>Работа Аристотеля по силлогизмам лежит в основе разработки формально-логических систем, которые относятся к структуре выводов и не зависят от содержания. Сейчас нам ясно, что главной целью формализации логики является высочайший уровень абстракции, нейтрализация и универсализация субъектов рассуждения, а также механизация процесса рассуждения и проверка его правильности.</p>
<p><strong>Формально-логические системы.</strong> Хотя логика силлогизмов Аристотеля заложила основы формальной логики, она не могла вполне достичь целей формализации, общности и механизации. Американский логик Льюис внес свой вклад в разработку символической логики, введя три ключевые характеристики, которым должна удовлетворять формальная логика:</p>
<ol class="arabic simple">
<li><p>Использование символов для понятий: В формальной логике символы представляют понятия. Например, символ <span class="math notranslate nohighlight">\(\times\)</span> обозначает умножение, и в языках программирования с той же целью пользуются символом *. Символы позволяют достичь абстракции и обобщенности логических рассуждений.</p></li>
<li><p>Метод логического вывода (дедукции): В формальной логике используется дедуктивный метод, позволяющий получить бесконечно много новых структур из конечного множества простых структур. Из нескольких основных структур получаются сложные процессы. Это обеспечивает возможность систематически получать новые выводы из принятых посылок.</p></li>
<li><p>Использование переменных: Переменные обозначают некоторый элемент заданного множества, что обеспечивает гибкость и абстрактность логических выражений. Переменные могут представлять любой объект в рамках заданной области, делая возможным обобщение в разных контекстах.</p></li>
</ol>
<p>Мы можем определить, что составляет формально-логическую систему, согласно этим принципам.</p>
<p><u>Определение.</u> Формально-логическая система <span class="math notranslate nohighlight">\(\mathcal S\)</span> определяется несколькими компонентами, которые вместе создают структурированную платформу для рассуждений. Вот ключевые компоненты формально-логической системы:</p>
<ul class="simple">
<li><p>Алфавит: Множество символов, используемых в этой системе.</p></li>
<li><p>Формальная грамматика: Множество синтаксических правил, определяющих, как могут быть выстроены символы алфавита, чтобы образовать правильные предложения или формулы.</p></li>
<li><p>Правила вывода: Множество правил, определяющее, как одну формула можно пошагово вывести из заданного множества формул (оно может быть пустым), называемых посылками. Эти правила регламентируют процессы логического вывода в системе.</p></li>
</ul>
<p>Правило с пустым множеством посылок называется аксиомой.</p>
<p>Итак, формальная система состоит из двух главных частей: формального языка и системы выводов (доказательств). Формальный язык обеспечивает структуру для выражения логических утверждений, а система выводов предлагает правила для получения новых утверждений и проверки правильности логических рассуждений.</p>
<p>Формально-логические системы упрощают точное формулирование и строгий анализ логических утверждений и их формальных доказательств, гарантируя, что выводы получены систематически и надежно. Изучение формально-логических систем также выявило важность формальных или полуформальных языков, таких, как математический язык, языки компьютерного программирования и языки спецификаций (или языки моделирования), вдобавок к формальным языкам логических систем. Если говорить о существенных преимуществах символических языков над прочими языками, в том числе естественными, можно процитировать Льюиса:</p>
<p>“… Во-вторых, идеографическая запись превосходит любую другую по точности. Многие идеи, выражаемые математическими символами, могут быть переданы обычным языком только с величайшими трудностями. Даже арифметика была бы сложной без идеограмм, а более высокие уровни были бы невозможны.” (“Обзор символической логики”, 1918 г.)</p>
<p>Формально-логические системы с гильбертовскими системами доказательств широко используются в науке. Как предложили Гильберт и Аккерман в книге “Принципы математической логики”, эти системы определяют аксиомы и правила вывода в схематической форме. В гильбертовских системах используется много схем аксиом и мало правил вывода.</p>
<p>В другом классе систем, называемых системами естественного вывода, напротив, вводится много правил вывода, но очень мало схем аксиом. Ниже мы представим вариант гильбертовской системы для исчисления предиктов первого порядка.</p>
<p><u>Определение.</u> Язык логики предикатов первого порядка <span class="math notranslate nohighlight">\(\mathcal L\)</span> определяется с помощью следующих синтаксических категорий.</p>
<ul class="simple">
<li><p>Алфавит <span class="math notranslate nohighlight">\(\Sigma\)</span>, состоящий из таких символов:</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(A = \{a_1, a_2, \ldots \}\)</span> - индивидные константы;</p></li>
<li><p><span class="math notranslate nohighlight">\(X = \{x_1, x_2, \ldots\}\)</span> - индивидные переменные;</p></li>
<li><p><span class="math notranslate nohighlight">\(F = \{f_1^1, f_2^1, \ldots, f_1^2, f_2^2, \ldots \}\)</span> - функциональные символы;</p></li>
<li><p><span class="math notranslate nohighlight">\(R = \{P_1^1, P_2^1, \ldots, P_1^2, P_2^2, \ldots \}\)</span> - предикатные символы;</p></li>
<li><p><span class="math notranslate nohighlight">\(()\)</span> - технические символы;</p></li>
<li><p><span class="math notranslate nohighlight">\(\forall\)</span> - квантор общности;</p></li>
<li><p><span class="math notranslate nohighlight">\(\neg\)</span>, <span class="math notranslate nohighlight">\(\to\)</span> - логические связки.</p></li>
</ul>
</li>
<li><p>Синтаксические правила:</p>
<ul>
<li><p>Термы: <span class="math notranslate nohighlight">\(t ::= a \;|\; x \;|\; f_i^n(t, \ldots, t)\)</span>, где <span class="math notranslate nohighlight">\(a \in A\)</span>, <span class="math notranslate nohighlight">\(x \in X\)</span>, <span class="math notranslate nohighlight">\(f_i^n \in F\)</span>;</p></li>
<li><p>Атомарные формулы: <span class="math notranslate nohighlight">\(AF ::= P^n_i(t, \ldots, t)\)</span>, где <span class="math notranslate nohighlight">\(P_i^n \in R\)</span>;</p></li>
<li><p>Формулы: <span class="math notranslate nohighlight">\(\varphi ::= Q \; | \; (\neg \varphi) \; | \; (\varphi \to \varphi) \; | \; (\forall x)\varphi\)</span>, где <span class="math notranslate nohighlight">\(Q \in AF\)</span>.</p></li>
</ul>
</li>
</ul>
<p>Это определение записано с помощью формы Бэкуса-Наура (BNF), которая обычно используется для определения синтаксиса языков программирования. Вообще языки программирования и формально-логические языки определяются сходным образом.</p>
<p>Например, вот так выглядит язык первого порядка <span class="math notranslate nohighlight">\(\mathcal N\)</span> для арифметики:</p>
<ul class="simple">
<li><p>Переменные: <span class="math notranslate nohighlight">\(x_1, x_2, \ldots\)</span></p></li>
<li><p>Индивидные константы: <span class="math notranslate nohighlight">\(a_1\)</span> - это константа <span class="math notranslate nohighlight">\(0\)</span></p></li>
<li><p>Предикат: <span class="math notranslate nohighlight">\(P_1^2\)</span> - это равенство <span class="math notranslate nohighlight">\(=\)</span></p></li>
<li><p>Функции:</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(f_1^1\)</span> - это функция следования</p></li>
<li><p><span class="math notranslate nohighlight">\(f_1^2\)</span> - это сложение</p></li>
<li><p><span class="math notranslate nohighlight">\(f_2^2\)</span> - это умножение</p></li>
</ul>
</li>
</ul>
<p>Важно отметить, что множество термов <span class="math notranslate nohighlight">\(\mathcal T\)</span> и множество формул <span class="math notranslate nohighlight">\(\mathcal F\)</span> являются рекурсивными. Следовательно, синтаксическая корректность терма или формулы - это разрешимое свойство. Это значит, что его можно проверить с помощью компьютерной программы.</p>
<p>Для языка первого порядка <span class="math notranslate nohighlight">\(\mathcal L\)</span> будем использовать систему доказательств <span class="math notranslate nohighlight">\(\mathcal K_{\mathcal L}\)</span> в виде гильбертовской системы со следующими 6 схемами аксиом и 2 правилами вывода:</p>
<ul class="simple">
<li><p>Аксиомы:</p>
<ul>
<li><p>(K1) <span class="math notranslate nohighlight">\((\varphi \to (\psi \to \varphi))\)</span></p></li>
<li><p>(K2) <span class="math notranslate nohighlight">\(((\varphi \to (\psi \to \theta)) \to ((\varphi \to \psi) \to (\varphi \to \theta)))\)</span></p></li>
<li><p>(K3) <span class="math notranslate nohighlight">\((((\neg \varphi) \to (\neg \psi)) \to (\psi \to \varphi))\)</span></p></li>
<li><p>(K4) <span class="math notranslate nohighlight">\((\forall x_i)\varphi \to \varphi\)</span>, где переменная <span class="math notranslate nohighlight">\(x_i\)</span> не имеет свободных вхождений в формулу <span class="math notranslate nohighlight">\(\varphi\)</span></p></li>
<li><p>(К5) <span class="math notranslate nohighlight">\((\forall x_i)\varphi \to \varphi(t)\)</span>, где терм <span class="math notranslate nohighlight">\(t\)</span> входит вместо всех свободных вхождений переменной <span class="math notranslate nohighlight">\(x_i\)</span> в формулу <span class="math notranslate nohighlight">\(\varphi\)</span></p></li>
<li><p>(K6) <span class="math notranslate nohighlight">\((\forall x_i)(\varphi \to \psi) \to (\varphi \to (\forall x_i)\psi)\)</span>, где переменная <span class="math notranslate nohighlight">\(x_i\)</span> не имеет свободных вхождений в формулу <span class="math notranslate nohighlight">\(\psi\)</span></p></li>
</ul>
</li>
<li><p>Правила вывода:</p>
<ul>
<li><p>Modus Ponens (MP): <span class="math notranslate nohighlight">\(\dfrac{\varphi, \; (\varphi \to \psi)}{\psi}\)</span></p></li>
<li><p>Обобщение (Gen): <span class="math notranslate nohighlight">\(\dfrac{\varphi}{(\forall x_i)\varphi}\)</span></p></li>
</ul>
</li>
</ul>
<p>Формулы (K1)-(K6) и правила вывода (MP), (Gen) - это схемы, из которых получается бесконечно много примеров. Например, две следующие формулы - это примеры (K1):</p>
<p><span class="math notranslate nohighlight">\((p_1 \to (p_2 \to p_2))\)</span></p>
<p><span class="math notranslate nohighlight">\((((\neg p_1) \to p_3) \to (((\neg p_3) \to p_4) \to ((\neg p_1) \to p_3)))\)</span></p>
<p>Вот пример для правила вывода (MP):</p>
<p><span class="math notranslate nohighlight">\(\dfrac{(p_1 \to ((\neg p_2) \to (\neg p_3))), \;\; ((p_1 \to ((\neg p_2) \to (\neg p_3))) \to (p_3 \to p_4))}{(p_3 \to p_4)}\)</span></p>
<p>Неформальный анализ показывает, что все примеры 6 схем аксиом правильны. В том смысле, что они выполняются в любой интерпретации.</p>
<p>В формально-логической системе понятия рассуждения (как процесса) и вывода формализовано в виде доказательств. А результат процесса рассуждений определяется как теорема этой системы.</p>
<p><u>Определение.</u> Для заданной формально-логической системы <span class="math notranslate nohighlight">\(\mathcal S\)</span> доказательство в этой системе определяется как конечная, непустая последовательность <span class="math notranslate nohighlight">\(\varphi_1, \ldots, \varphi_n\)</span> правильно построенных формул, таких, что каждая формула <span class="math notranslate nohighlight">\(\varphi_i\)</span> в этой последовательности - это либо аксиома, либо она выводится из предыдущих формул этой последовательности с помощью одного из правил вывода системы <span class="math notranslate nohighlight">\(\mathcal S\)</span>. Последняя формула <span class="math notranslate nohighlight">\(\varphi_n\)</span> в доказательстве называется теоремой этой системы, обозначается <span class="math notranslate nohighlight">\(\vdash_{\mathcal S} \varphi_n\)</span>.</p>
<p>Доказательства в формальной системе называются формальными доказательствами. Теоремы также формальны, поэтому не имеют предметного содержания. Согласно введенному определению, любой непустой префикс доказательства также является доказательством, и все формулы в доказательстве - это теоремы.</p>
<p>Пример формального доказательства в системе <span class="math notranslate nohighlight">\(\mathcal K_{\mathcal L}\)</span>:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\((P_1^1(x_1) \to (P_2^2(x_1, x_2) \to P_1^1(x_1)))\)</span> - из схемы аксиом (K1)</p></li>
<li><p><span class="math notranslate nohighlight">\(((P_1^1(x_1) \to (P_2^2(x_1, x_2) \to P_1^1(x_1))) \to ((P_1^1(x_1) \to P_2^2(x_1, x_2)) \to (P_1^1(x_1) \to P_1^1(x_1))))\)</span> - из схемы аксиом (K2)</p></li>
<li><p><span class="math notranslate nohighlight">\(((P_1^1(x_1) \to P_2^2(x_1, x_2)) \to (P_1^1(x_1) \to P_1^1(x_1)))\)</span> - по правилу (MP) из 1, 2</p></li>
<li><p><span class="math notranslate nohighlight">\((\forall x_1)((P_1^1(x_1) \to P_2^2(x_1, x_2)) \to (P_1^1(x_1) \to P_1^1(x_1)))\)</span> - по правилу (Gen) из 3</p></li>
<li><p><span class="math notranslate nohighlight">\((\forall x_2)(\forall x_1)((P_1^1(x_1) \to P_2^2(x_1, x_2)) \to (P_1^1(x_1) \to P_1^1(x_1)))\)</span> - по правилу (Gen) из 4</p></li>
</ol>
<p>В формальном доказательстве конкретные примеры схем аксиом и схем правил вывода получаются в результате сопоставления шаблонов.</p>
<p>Можно видеть, что три ключевых аспекта аристотелевской логики выполняются для формальных доказательств. Например, отделение формы от содержания и требование явного указания всех посылок. Каждый тип силлогизмов можно формализовать в качестве правила вывода. Например, силлогизм из нашего текстового примера можно записать так:</p>
<p><span class="math notranslate nohighlight">\(\dfrac{(\forall x_i)(\varphi(x_i) \to \psi(x_i)), \;\; \varphi(a_i)}{\psi(a_i)}\)</span></p>
<p>Правильность данного правила вытекает из правильности формулы</p>
<p><span class="math notranslate nohighlight">\((((\forall x_i)(\varphi(x_i) \to \psi(x_i)) \land \psi(a_i)) \to \psi(a_i))\)</span></p>
<p>В качестве упражнения можно построить доказательство этой формулы как теоремы в системе <span class="math notranslate nohighlight">\(\mathcal K_{\mathcal L}\)</span>.</p>
<p>Рассуждение в примере неправильного рассуждения можно формализовать следующим образом:</p>
<p><span class="math notranslate nohighlight">\(\dfrac{(\exists x_i)(\varphi(x_i) \land \psi(x_i)), \;\; \varphi(a_i)}{\psi(a_i)}\)</span></p>
<p>Легко понять, что это неправильное правило, и соответствующая формула не является теоремой:</p>
<p><span class="math notranslate nohighlight">\((((\exists x_i)(\varphi(x_i) \land \psi(x_i)) \land \varphi(a_i)) \to \psi(a_i))\)</span></p>
<p>Поэтому такое рассуждение будет неправильным.</p>
<p>Создание формальных доказательств непосредственно на основе аксиом и правил вывода является утомительным и сложным делом. Однако основная цель формализации логических выводов состоит в том, чтобы обеспечить строгость и систематичность изложения доказательств и обеспечить возможность механической проверки их достоверности. Кроме того, изучение теории доказательств также привело к разработке методов формального доказательства теорем. В частности, методы формального доказательства теорем быстро развивались благодаря исследованиям и разработке автоматизированных средств.</p>
<p><strong>Метатеория формально-логических систем.</strong> Изучение интерпретаций (или семантики) и представлений, а также свойств доказательств в формально-логических системах - это ключевые аспекты металогики. Первый из них относится к теории моделей, второй - к теории доказательств. Всеобъемлющая цель состоит в том, чтобы изучить, как формальная логика и математика взаиосвязаны с формализмами и их областями применения.</p>
<p><em>Интерпретация формальных языков.</em> Применяя формально-логическую систему к изучению интересующей области, всегда нужна интерпретация формул (предложений) формального языка как утверждений об этой области. Тем самым форма увязывается с содержанием предмета исследования. Интерпретация формулы относится к семантике (или смысловому значению) формулы в данной области. Следуя индуктивно синтаксису формального языка, производится сопоставление символическим элементам формального языка их семантики, то есть элементов предметной области. Давайте покажем, как вводится интерпретация языка <span class="math notranslate nohighlight">\(\mathcal L\)</span> гильбертовской системы логики первого порядка.</p>
<p><u>Определение.</u> Интерпретация <span class="math notranslate nohighlight">\(\mathcal I = (D, I)\)</span> языка первого порядка <span class="math notranslate nohighlight">\(\mathcal L\)</span> состоит из носителя интерпретации <span class="math notranslate nohighlight">\(D\)</span>, представляющего собой множество, а также многосортного отображения <span class="math notranslate nohighlight">\(I\)</span> из синтаксических категорий в элементы, функции и отношения, заданные на <span class="math notranslate nohighlight">\(D\)</span>:</p>
<ul class="simple">
<li><p>Семантика константных символов: <span class="math notranslate nohighlight">\(I \colon A = \{a_1, \ldots\} \mapsto D\)</span> - отображение из <span class="math notranslate nohighlight">\(A\)</span> в <span class="math notranslate nohighlight">\(D\)</span>. Обозначаем <span class="math notranslate nohighlight">\(I(a_i)\)</span> через <span class="math notranslate nohighlight">\(\overline{a_i}\)</span> - это означивание символа <span class="math notranslate nohighlight">\(a_i\)</span>.</p></li>
<li><p>Семантика функциональных символов: <span class="math notranslate nohighlight">\(I \colon F \mapsto \{f^n \colon f^n \text{ - это }n\text{-арная функция на }D\}\)</span>. Это отображение сопоставляет каждому функциональному символу функцию из <span class="math notranslate nohighlight">\(D\)</span>. Обозначаем <span class="math notranslate nohighlight">\(I(f_i^k)\)</span> через <span class="math notranslate nohighlight">\(\overline{f_i^k}\)</span> - это означивание символа <span class="math notranslate nohighlight">\(f_i^k\)</span>.</p></li>
<li><p>Семантика предикатных символов: <span class="math notranslate nohighlight">\(I \colon R \mapsto \{P^n \colon P^n \text{ - это }n\text{-арное отношение на }D\}\)</span>. Это отображение сопоставляет каждому предикатному символу отношения на <span class="math notranslate nohighlight">\(D\)</span>. Обозначаем <span class="math notranslate nohighlight">\(I(P_i^k)\)</span> через <span class="math notranslate nohighlight">\(\overline{P_i^k}\)</span> - это означивание символа <span class="math notranslate nohighlight">\(P_i^k\)</span>.</p></li>
</ul>
<p>Для заданной интерпретации <span class="math notranslate nohighlight">\(\mathcal I\)</span> языка первого порядка можно определить значение термов и формул в рамках языка.</p>
<p><u>Определение.</u> В рамках заданной интерпретации <span class="math notranslate nohighlight">\(\mathcal I = (D, I)\)</span> языка первого порядка <span class="math notranslate nohighlight">\(\mathcal L\)</span> оценка термов сопоставляет термам их значения из <span class="math notranslate nohighlight">\(D\)</span>. Оценка формул сопоставляет формулам истинностные значения из множества <span class="math notranslate nohighlight">\(\{tt, ff\}\)</span>. Формально, оценка <span class="math notranslate nohighlight">\(\sigma\)</span> термов языка <span class="math notranslate nohighlight">\(\mathcal L\)</span> - это отображение из множества термов <span class="math notranslate nohighlight">\(\mathcal T\)</span> в множество <span class="math notranslate nohighlight">\(D\)</span>, т.е. <span class="math notranslate nohighlight">\(\sigma \colon \mathcal T \mapsto D\)</span>, которое удовлетворяет следующим условиям:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(\sigma(a_i) = \overline{a_i}\)</span> для <span class="math notranslate nohighlight">\(a_i \in A\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(\sigma(f_i^n(t_1, \ldots, t_n)) = \overline{f_i^n}(\sigma(t_1), \ldots, \sigma(t_n))\)</span> для <span class="math notranslate nohighlight">\(f_i^n \in F\)</span>.</p></li>
</ol>
<p>Оценку термов можно расширить для оценки формул, которую также обозначим через <span class="math notranslate nohighlight">\(\sigma\)</span>, это отображение <span class="math notranslate nohighlight">\(\sigma \colon \mathcal F \to \{tt, ff\}\)</span>, такое, что:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(\sigma(P_i^n(t_1, \ldots, t_n)) = tt\)</span>, если и только если <span class="math notranslate nohighlight">\(\overline{P_i^n}(\sigma(t_1), \ldots, \sigma(t_n))\)</span> выполняется в <span class="math notranslate nohighlight">\(D\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(\sigma(\neg\varphi) = tt\)</span>, если и только если <span class="math notranslate nohighlight">\(\sigma(\varphi) = ff\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(\sigma(\varphi \to \psi) = tt\)</span>, если и только если <span class="math notranslate nohighlight">\(\sigma(\varphi) = ff\)</span> или <span class="math notranslate nohighlight">\(\sigma(\psi) = tt\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(\sigma((\forall x_i)\varphi) = tt\)</span>, если и только если <span class="math notranslate nohighlight">\(\sigma'(\varphi) = tt\)</span> для всякой оценки <span class="math notranslate nohighlight">\(\sigma'\)</span>, совпадающей с <span class="math notranslate nohighlight">\(\sigma\)</span>, кроме, возможно, переменной <span class="math notranslate nohighlight">\(x_i\)</span>.</p></li>
</ol>
<p>Например, можно определить интерпретацию <span class="math notranslate nohighlight">\(\mathcal I\)</span> для языка первого порядка <span class="math notranslate nohighlight">\(\mathcal N\)</span>, задав следующие отображения: <span class="math notranslate nohighlight">\(\overline{a_1}\)</span> - это <span class="math notranslate nohighlight">\(0\)</span>, <span class="math notranslate nohighlight">\(\overline{f_1^1}\)</span> - это функция следования (т.е. <span class="math notranslate nohighlight">\(\overline{f_1^1} = x + 1\)</span>), <span class="math notranslate nohighlight">\(\overline{f_1^2}\)</span> - это сложение, <span class="math notranslate nohighlight">\(\overline{f_2^2}\)</span> - это умножение, и <span class="math notranslate nohighlight">\(\overline{P^2_1}\)</span> - это отношение равенства “<span class="math notranslate nohighlight">\(=\)</span>”. При такой интерпретации смысловое значение формул можно проиллюстрировать следующим образом:</p>
<ol class="arabic simple">
<li><p>Формула <span class="math notranslate nohighlight">\((\forall x_1)(\neg P_1^2(f_1^1(x_1), x_1))\)</span> формально обозначает утверждение, что для всех <span class="math notranslate nohighlight">\(x\)</span> выполнено <span class="math notranslate nohighlight">\(x + 1 \neq x\)</span>.</p></li>
<li><p>Формула <span class="math notranslate nohighlight">\((\forall x_1)(\forall x_2)(P_1^2(f_1^2(x_1, x_2), f_1^2(x_2, x_1)))\)</span> формально обозначает утверждение, что для всех натуральных чисел выполнено <span class="math notranslate nohighlight">\(x_1 + x_2 = x_2 + x_1\)</span> (т.е. что сложение коммутативно).</p></li>
<li><p>Формула <span class="math notranslate nohighlight">\((\forall x_1)(\forall x_2)(\forall x_3)(P_1^2(f_2^2(x_3, f_1^2(x_1, x_2)), f_1^2(f_2^2(x_3,x_1), f_2^2(x_3,x_2))))\)</span> обозначает закон дистрибутивности умножения относительно сложения: <span class="math notranslate nohighlight">\((x_3 \times (x_1 + x_2)) = (x_3 \times x_1) + (x_3 \times x_2)\)</span>.</p></li>
</ol>
<p>Все три формулы выполняются при любой оценке при указанной интерпретации.</p>
<p>Теперь мы поняли, что формально-логическая система имеет три составляющие: формальный язык, связанная с ним система доказательств и семантика (т.е. интерпретации).</p>
<p><em>Важные метатеоремы, касающиеся формально-логических систем.</em> Введем основополагающие понятия формально-логических систем.</p>
<p><u>Определение.</u> Пусть <span class="math notranslate nohighlight">\(\mathcal I\)</span> - интерпретация языка первого порядка <span class="math notranslate nohighlight">\(\mathcal L\)</span>. Тогда:</p>
<ul class="simple">
<li><p>Говорят, что формула <span class="math notranslate nohighlight">\(\varphi\)</span> выполняется на оценке <span class="math notranslate nohighlight">\(\sigma\)</span> при интерпретации <span class="math notranslate nohighlight">\(\mathcal I\)</span>, обозначение <span class="math notranslate nohighlight">\((\mathcal I, \sigma) \models \varphi\)</span>, если <span class="math notranslate nohighlight">\(\sigma(\varphi) = tt\)</span>.</p></li>
<li><p>Формула <span class="math notranslate nohighlight">\(\varphi\)</span> называется выполнимой при интерпретации <span class="math notranslate nohighlight">\(\mathcal I\)</span>, если существует оценка <span class="math notranslate nohighlight">\(\sigma\)</span>, такая, что <span class="math notranslate nohighlight">\((\mathcal I, \sigma) \models \varphi\)</span>.</p></li>
<li><p>Интерпретация <span class="math notranslate nohighlight">\(\mathcal I\)</span> называется моделью формулы <span class="math notranslate nohighlight">\(\varphi\)</span>, если <span class="math notranslate nohighlight">\(\varphi\)</span> выполняется на каждой оценке при интерпретации <span class="math notranslate nohighlight">\(\mathcal I\)</span>, обозначение <span class="math notranslate nohighlight">\(\mathcal I \models \varphi\)</span>.</p></li>
</ul>
<p>Формула <span class="math notranslate nohighlight">\(\varphi\)</span> называется общезначимой, обозначение <span class="math notranslate nohighlight">\(\models \varphi\)</span>, если она выполняется при всех интерпретациях (т.е. каждая возможная интерпретация - модель формулы <span class="math notranslate nohighlight">\(\varphi\)</span>).</p>
<p>Эти основополагающие концепции приводят к следующим задачам:</p>
<ul class="simple">
<li><p>Если заданы интерпретация и формула, удовлетворяет ли конкретная оценка формуле?</p></li>
<li><p>Если заданы интерпретация и формула, является ли формула выполнимой?</p></li>
<li><p>Является ли данная интерпретация моделью формулы?</p></li>
</ul>
<p>Изучение этих проблем является центральным направлением в области разрешимости, а также тестирования и верификации программного обеспечения.</p>
<p>Пусть имеется логическая система <span class="math notranslate nohighlight">\(\mathcal S\)</span>. Следующие метасвойства носят фундаментальный характер, касающийся соотношения между формальным языком и его семантикой, то есть между формальными спецификациями и моделями:</p>
<ul class="simple">
<li><p>Непротиворечивость: Логическая система <span class="math notranslate nohighlight">\(\mathcal S\)</span> непротиворечива, если не существует такой формулы <span class="math notranslate nohighlight">\(\varphi\)</span>, что как <span class="math notranslate nohighlight">\(\varphi\)</span>, так и <span class="math notranslate nohighlight">\(\neg\varphi\)</span> являются теоремами <span class="math notranslate nohighlight">\(\mathcal S\)</span>, то есть не бывает одновременно <span class="math notranslate nohighlight">\(\vdash_{\mathcal S} \varphi\)</span> и <span class="math notranslate nohighlight">\(\vdash_{\mathcal S} \neg\varphi\)</span>.</p></li>
<li><p>Корректность: Логическая система <span class="math notranslate nohighlight">\(\mathcal S\)</span> корректна, если всякая теорема <span class="math notranslate nohighlight">\(\mathcal S\)</span> верна, т.е. если <span class="math notranslate nohighlight">\(\vdash_S \varphi\)</span>, то <span class="math notranslate nohighlight">\(\models\varphi\)</span>.</p></li>
<li><p>Адекватность: Логическая система <span class="math notranslate nohighlight">\(\mathcal S\)</span> адекватна, если всякая правильная формула - теорема этой системы, т.е. если <span class="math notranslate nohighlight">\(\models\varphi\)</span>, то <span class="math notranslate nohighlight">\(\vdash_{\mathcal S}\varphi\)</span>.</p></li>
<li><p>Полнота: Логическая система <span class="math notranslate nohighlight">\(\mathcal S\)</span> полна, если не бывает замкнутой (т.е. без свободных переменных) формулы <span class="math notranslate nohighlight">\(\varphi\)</span>, такой, что ни <span class="math notranslate nohighlight">\(\varphi\)</span>, ни <span class="math notranslate nohighlight">\(\neg\varphi\)</span> не являются теоремами <span class="math notranslate nohighlight">\(\mathcal S\)</span>, т.е. всегда либо <span class="math notranslate nohighlight">\(\vdash_{\mathcal S} \varphi\)</span>, либо <span class="math notranslate nohighlight">\(\vdash_{\mathcal S} (\neg \varphi)\)</span>.</p></li>
</ul>
<p>Упомянутые свойства относятся к описательной и доказательной возможностям формальных систем. Корректная система должна быть непротиворечивой, хотя обратное не всегда верно.</p>
<p>В общем, логическая система первого порядка - это логическая система <span class="math notranslate nohighlight">\(\mathcal S\)</span>, определенная на языке первого порядка <span class="math notranslate nohighlight">\(\mathcal L\)</span>, такая, что все теоремы гильбертовской системы <span class="math notranslate nohighlight">\(\mathcal K_{\mathcal L}\)</span> также являются теоремами системы <span class="math notranslate nohighlight">\(\mathcal S\)</span>. Таким образом, <span class="math notranslate nohighlight">\(\mathcal S\)</span> называется расширением  <span class="math notranslate nohighlight">\(\mathcal K_{\mathcal L}\)</span>. Формальная математическая система - это расширение  <span class="math notranslate nohighlight">\(\mathcal K_{\mathcal L}\)</span>, включающее в себя аксиомы для предиката равенства “<span class="math notranslate nohighlight">\(=\)</span>”. Примерами формальной математической системы служат: арифметика натуральных чисел, булева алгебра, аксиоматическая теория групп и аксиоматическая теория множеств ZFC.</p>
<p>Можно показать, что гильбертовская система <span class="math notranslate nohighlight">\(\mathcal K_{\mathcal L}\)</span> для языка первого порядка <span class="math notranslate nohighlight">\(\mathcal L\)</span> обладает одновременно и корректностью (и поэтому непротиворечива), и адекватностью, как показал Гёдель в 1929 г. Однако <span class="math notranslate nohighlight">\(\mathcal K_{\mathcal L}\)</span> неполна, потому что ни <span class="math notranslate nohighlight">\((\forall x_i)P^1_1(x_i)\)</span>, ни <span class="math notranslate nohighlight">\((\neg(\forall x_i)P_1^1(x_1))\)</span> не являются теоремами этой системы. Можно доказать, что во всяком противоречивом расширении <span class="math notranslate nohighlight">\(\mathcal K_{\mathcal L}\)</span> любая формула становится теоремой, что делает систему непригодной для использования.</p>
<p><u>Теорема.</u> (теорема Гёделя о неполноте). Любая непротиворечивая система, в которой можно выразить арифметику натуральных чисел, обладает неполнотой.</p>
<p>В любой непротиворечивой формально-логической системе, достаточно богатой для описания арифметики натуральных чисел (например, арифметика Пеано), существуют истинные утверждения о натуральных числах, которые в рамках этой системы невозможно ни доказать, ни опровергнуть.</p>
<p><strong>Важность математической логики и следствия теоремы Гёделя.</strong> Главным преимуществом изучения математической логики является ее строгая структура для систематического рассуждения и решения проблем. Дедуктивная логика облегчает точный вывод теорем из установленных аксиом и принципов, часто основанных на наблюдениях и интуиции, и обеспечивает последовательность, надежность (обоснованность) и полноту теорий и технологий.</p>
<p><em>Сила и полезность формальной логики.</em>
Развитие формальной логики демонстрирует ее огромную мощь в создании сложных структур и процессов на основе простых правил, механически выполняя рекурсию и итерацию. Применяя принципы структуры, методы, основанные на синтаксисе, и абстракции, формальная логика обеспечивает систематическую основу для анализа сложности и управления ею. Такие методы, как эквивалентность и подстановка следствия, позволяют точно манипулировать сложными системами, обеспечивая модульность, повторное использование и подход “разделяй и властвуй” в инженерных дисциплинах, в частности в разработке компьютерных систем.</p>
<p>Изучение математической логики развивает строгость, последовательность и многоплановое мышление, что необходимо для построения последовательных моделей мышления. Кроме того, изучение и практика логики развивает независимое и критическое мышление, что делает ее бесценным инструментом для теоретических исследований и решения практических задач.</p>
<p><em>Творческий потенциал человека в сложных логических системах.</em> Все логические системы по своей сути ограничивают рассуждения и анализ, используя фиксированные языки и придерживаясь предопределенных аксиом и правил вывода. Набор теорем в рамках логической системы является замкнутым относительно следствий, вытекающих из ее аксиом и правил. В этом смысле рассуждения или доказательство теорем в рамках логической системы представляют собой открытие новых идей, а не создание чего-то нового из ничего.</p>
<p>Всякая теория основана на определенной логической системе. В рамках этой системы устанавливаются основные допущения, определяются ключевые концепции, формулируются утверждения и проводится их анализ. “Язык” логической системы неизменен, и теоремы являются всего лишь выводами из этих предположений. Изучение такой теории может привести к доказательству новых теорем и развитию дальнейших идей и приложений. Однако этот процесс не является подлинной “инновацией”, основанной только на рассуждениях.</p>
<p>Новые теории возникают, когда оспариваются существующие аксиомы или предположения, часто в ответ на наблюдения или проблемы, которые не могут быть адекватно решены с помощью существующей логики. Это требует выдвижения новых аксиом, построения новых моделей и определения новых концепций. Переосмысливая эти основополагающие элементы, мы можем формулировать инновационные идеи и теории, расширяя границы знаний за пределы существующей логической системы. Здесь мы определяем “созидание” как инновацию, которая обычно создает новые теории, предполагающие расширение языка, необходимого для формулирования новых концепций, аксиом, правил вывода и моделей.</p>
<p>Понимание этого вида творчества можно проиллюстрировать на примере изучения изменений парадигмы в науке, таких как переход от ньютоновской механики к теории относительности Эйнштейна, от евклидовой геометрии к неевклидовой и от геоцентрической к гелиоцентрической модели Солнечной системы. Эти примеры иллюстрируют, как фундаментальные изменения в предположениях, аксиомах и даже в языках, используемых для их описания, могут привести к созданию совершенно новых систем мышления. Вопросы и переосмысление основополагающих элементов являются ключевыми для научного прогресса и интеллектуального творчества человека.</p>
<p><em>Возможности компьютеров в области логического мышления и инноваций.</em> Это обсуждение приводит нас к убеждению, что способность наблюдать факты или проблемы, которые существующая логическая система не может адекватно решить, и оспаривать ее преобладающие предположения, предлагая новые концепции, аксиомы и, в конечном счете, новые логические системы, является ключевым элементом человеческого интеллекта. Если мы рассматриваем структуру человеческого знания или архитектуру системы человеческого знания как включающую устоявшиеся теории и их взаимосвязи, то ее эволюция определяется 1) открытием новых теорем и применений существующих теорий, а также 2) созданием новых теорий. Даже при таком упрощенном взгляде на знания мы можем утверждать, что, хотя компьютерные программы, включая системы глубокого обучения, обладают огромным потенциалом для развития первого типа, в настоящее время они не могут способствовать развитию второго типа.</p>
<p>Эта точка зрения, хотя и спорная и научно не доказуемая (по крайней мере, в настоящее время), будет более подробно разъяснена в следующих разделах, где мы обсудим взаимосвязь между формальной логикой, теорией вычислений и программированием.</p>
<p><em>Философские следствия теоремы Гёделя.</em>
Гёдель открыл несколько фундаментальных теорем, включая теорему о неполноте, которые вместе часто называют просто теоремой Гёделя. Эти теоремы могут быть выражены в нескольких эквивалентных формах:</p>
<ul class="simple">
<li><p>Математика неисчерпаема.</p></li>
<li><p>Любая непротиворечивая формальная математическая теория должна содержать неразрешимые утверждения.</p></li>
<li><p>Ни один компьютер (или программа), доказывающий теоремы, не может доказать все и только истинные математические утверждения.</p></li>
<li><p>Ни одна формальная математическая система не может быть одновременно непротиворечивой и полной.</p></li>
<li><p>Математика механически (или алгоритмически) неисчерпаема (или неполна).</p></li>
</ul>
<p>Следовательно, теорема Гёделя подразумевает некоторые фундаментальные ограничения использования компьютеров в математике, даже в самой простой математической области - арифметике.</p>
<p>С философской точки зрения теорема Гёделя раскрывает несколько ключевых диалектических аспектов:</p>
<ul class="simple">
<li><p>Логика и интуиция – Логика не может полностью охватить все аспекты интуиции.</p></li>
<li><p>Формализм и содержание – Формальные системы представляют собой абстракции, но они не могут охватить все богатство содержания.</p></li>
<li><p>Механическое и умственное – Вопрос о том, все ли аспекты человеческого интеллекта могут быть механизированы, остается под вопросом.</p></li>
<li><p>Язык и мышление – Хотя язык является мощным инструментом для выражения мыслей, он не может в полной мере передать все идеи, эмоции или аспекты человеческого сознания.</p></li>
<li><p>Истина и доказуемость – Формальные системы доказывают не все истины.</p></li>
<li><p>Реальное и познаваемое – Человеческое знание о реальности по своей сути ограничено и постоянно развивается.</p></li>
</ul>
<p>Эти философские выводы подчеркивают ограниченность формальных систем и бросают вызов представлению о том, что механические или алгоритмические процессы могут полностью охватывать все аспекты математики, знаний или человеческого мышления. Работа Гёделя побуждает к постоянным размышлениям о границах логики, природе истины, сложности человеческого познания и возможностях машин (или программ). На наш взгляд, эти выводы могут оказать важное влияние на понимание различий и взаимосвязей между возможностями человеческого разума и машин, включая DNN (глубокие нейронные сети) и LLM (большие языковые модели). Гёдель проявил значительный интерес к доказательству того, что человеческий разум превосходит машины в математике, хотя и без особых существенных результатов.</p>
</section>
<section id="id4">
<h2>Вычислительные модели и теории<a class="headerlink" href="#id4" title="Link to this heading">#</a></h2>
<p>В этом разделе вычисления рассматриваются как фундаментальный аспект человеческого интеллекта и делается упор на развитие теорий, методов, инструментов и приспособлений посредством межкультурного творчества как важнейших компонентов человеческой цивилизации. Мы прослеживаем, как вычислительные модели и теории возникли в результате решения фундаментальных математических задач путем определения логических систем, тем самым заложив естественную основу для современной информатики.</p>
<section id="id5">
<h3>Вычисления в истории цивилизации<a class="headerlink" href="#id5" title="Link to this heading">#</a></h3>
<p>Вычисления были фундаментальным аспектом человеческой жизни с древних времен. Древние люди использовали камни или глиняные таблички для подсчета и отслеживания поголовья скота в своих стадах, в то время как торговцы разработали такие методы, как завязывание узлов на веревках для записи расчетов в целях торговли.</p>
<p><strong>Ранняя история вычислений и устройств.</strong>
Вычислительная техника - это уникальная способность человека, которая прогрессировала естественным образом и систематически развивается через образование. В современном обществе люди рано приобретают базовые навыки работы с компьютером, проходя различные этапы обучения – от детского сада до начальной и средней школы и, в конечном итоге, до получения высшего образования. На протяжении всего этого образовательного пути учащиеся знакомятся с математическими понятиями, включая арифметику (сложение, вычитание, умножение и деление), решение уравнений, геометрические доказательства, логарифмы, математический анализ и логические рассуждения. Важнейшим элементом вычислений в этом учебном процессе является его неотъемлемая природа, основанная на правилах, где структурированные принципы лежат в основе решения проблем и направляют процесс принятия решений.</p>
<p><img alt="" src="_images/fig1.png" /></p>
<p>Вычисления были движущей силой прогресса человеческой цивилизации, поскольку развитие вычислительных технологий и инструментов неразрывно связано с развитием общества. Человечество стремилось упростить и систематизировать вычисления, которые развивались на протяжении тысячелетий наряду с достижениями в математике, инженерии и технологии. Ранние формы вычислительных методов и инструментов восходят к древним цивилизациям, где были разработаны базовые системы счета. Такие инструменты, как счетные палочки (на рис. 1а) и счеты (на рис. 1б) в Китае, глиняные жетоны в Месопотамии и египетская иероглифическая система счисления заложили основу для более сложных методов арифметики.</p>
<p>В средневековом исламском мире такие ученые, как Аль-Хорезми, ввели алгебру и алгоритмы (термин, образованный от его имени), которые оказали значительное влияние на более поздние европейские математические традиции. Изобретение механических часов в 14 веке продемонстрировало растущую сложность механических вычислений.</p>
<p>К 17 веку европейские математики и изобретатели, такие как Блез Паскаль и Готфрид Вильгельм Лейбниц, начали создавать первые механические калькуляторы, такие как арифмометр Паскаля (рис. 2а) и ступенчатый счетный механизм Лейбница (рис. 2б). Эти устройства, хотя и были ограничены, положили начало автоматизированным вычислениям.</p>
<p><img alt="" src="_images/fig2.png" /></p>
<p>В начале 19 века Чарльз Бэббидж и Ада Лавлейс представили вычислительные машины, которые заложили основу для современных вычислений. В 1820-х годах Бэббидж разработал “разностную машину” для автоматизации математических вычислений. На рис. 3 представлена реконструкция первоначальных планов, хранящихся в Музее науки в Лондоне. В 1830-х годах он разработал более амбициозную “аналитическую машину” - механическое устройство, которое могло выполнять любые вычисления с помощью программируемых инструкций. В 1840-х годах Ада Лавлейс осознала далеко идущий потенциал изобретения Бэббиджа. Часто считающаяся первым компьютерным программистом, она выдвинула теорию о том, что эти машины могут манипулировать символами и выполнять сложные алгоритмы, подготовив почву для цифровой революции более чем за столетие до того, как она произошла.</p>
<p><img alt="" src="_images/fig3.png" /></p>
<p><strong>Истоки вычислительных моделей и вычисляемость.</strong>
Изучение истории, понимания и практики вычислений, наряду с развитием механических вычислительных устройств и машин, привело к появлению моделей вычислений в начале 20-го века. В первую очередь это стало результатом усилий математиков, которые в рамках программы Гильберта решали, в частности, проблему разрешимости Гильберта-Аккермана. Критический подход заключается в строгом определении того, что означает, что проблема разрешима или что функция или задача вычислима. Наиболее фундаментальными и хорошо изученными моделями являются рекурсивные функции, λ-исчисление и машины Тьюринга. Каждая из них предоставляет различные, но в конечном счете эквивалентные платформы для представления вычислений.</p>
</section>
<section id="id6">
<h3>Рекурсивные функции<a class="headerlink" href="#id6" title="Link to this heading">#</a></h3>
<p>У рекурсивных функций определяют их значения для нескольких базовых случаев, т.е. для “малых” аргументов, а значения для большего аргумента вычисляется рекурсивно путем применения той же функции к меньшим аргументам, шаг за шагом, пока не будут достигнуты значения для базовых случаев.</p>
<p>Простым примером рекурсивной функции является факториал <span class="math notranslate nohighlight">\(n!\)</span>. Обозначим эту функцию через <span class="math notranslate nohighlight">\(fct(n)\)</span>, и тогда она будет определена следующим образом:</p>
<p><span class="math notranslate nohighlight">\(fct(0) = 1, \quad fact(n + 1) = (n + 1) \times fct(n)\)</span>.</p>
<p>Эта функция определена для любого аргумента <span class="math notranslate nohighlight">\(n \geq 0\)</span>.
При <span class="math notranslate nohighlight">\(n = 0\)</span> факториал равен 1, а для любого <span class="math notranslate nohighlight">\(n &gt; 0\)</span> значение функции вычисляется путем последовательного “разворачивания” выражения <span class="math notranslate nohighlight">\((n + 1) \times fct(n)\)</span> до тех пор, пока не будет достигнут базовый вариант <span class="math notranslate nohighlight">\(0! = 1\)</span>.
Например, значение <span class="math notranslate nohighlight">\(4!\)</span> может быть вычислено следующим образом:</p>
<p><span class="math notranslate nohighlight">\(fct(4) = 4 \times fct(3) =\)</span></p>
<p><span class="math notranslate nohighlight">\( = 4 \times (3 \times fct(2)) =\)</span></p>
<p><span class="math notranslate nohighlight">\(= 4 \times (3 \times (2 \times fct(1))) =\)</span></p>
<p><span class="math notranslate nohighlight">\(= 4 \times (3 \times (2 \times (1 \times 1))) =\)</span></p>
<p><span class="math notranslate nohighlight">\( = 24 \)</span></p>
<p>Таким образом, значение функции для любого заданного входного аргумента вычисляется шаг за шагом в соответствии с правилом развертывания, которое вытекает из определяющих рекуррентных соотношений. Мы можем понимать определяющие выражения рекурсивной функции как аксиомы и правила дедукции, которые также определяют алгоритм вычисления функции, т.е. эффективную процедуру вычисления ее значений, которую человек или механическое вычислительное устройство может выполнить за конечное число шагов. Эти этапы вычислений имеют ту же форму, что и вывод в доказательствах логических формул первого порядка с заменой эквивалентных.</p>
<p>Позже в этом разделе мы увидим, что λ-исчисление и теория машин Тьюринга показывают, что любое вычисление (процесс) может быть представлено в виде серии формальных логических выводов. Следуя той же линии исследований, что и машины Тьюринга, продукционные системы Поста также моделируют вычисления как вывод доказательства, где вычисления представляют собой поэтапный процесс получения результатов из исходных посылок с использованием правил.</p>
<p><strong>Ранняя история рекурсивных определений.</strong>
Известным примером такого рекурсивного определения является последовательность чисел Фибоначчи: 0, 1, 1, 2, 3, 5, … В этой последовательности, начиная с третьего числа, каждое последующее число является суммой двух предыдущих:</p>
<p><span class="math notranslate nohighlight">\(F_0 = 0,\; F_1 = 1,\; F_n = F_{n-1} + F_{n-2} \text{ для } n \geq 2\)</span></p>
<p>Эта последовательность названа в честь итальянского математика Леонардо Пизанского, также известного как Фибоначчи, который представил ее западноевропейской математике в своей книге “Liber Abaci”, опубликованной в 1202 году. Однако эта последовательность была открыта индийскими математиками еще в 200 году до нашей эры, а описания подобных последовательностей можно найти в греческих, египетских и санскритских источниках, датируемых 700 годом до нашей эры.</p>
<p>Систематические исследования рекурсивных функций основаны на математической логике, в частности, на так называемой теории рекурсивных функций, которую в настоящее время чаще называют теорией вычислимости. Интерес к рекурсивным функциям первоначально возник в результате дискуссий о создании основ арифметики. Повторяющиеся определения сыграли решающую роль в формулировании математической индукции как метода рассуждения о натуральных числах. Первые хорошо известные рекурсивные определения были даны Грассманом (1861) и Пирсом (1881), которые использовали их для определения сложения и умножения натуральных чисел и доказательства ассоциативных, коммутативных и дистрибутивных законов для этих операций.</p>
<p>Похоже, что термин “определение с помощью рекурсии” впервые появился в эссе Дедекинда “Что такое числа и какими свойствами они должны обладать” (1888). В этой статье Дедекинд представил теорию множеств для арифметики и доказал теоремы о существовании и единственности функций, определяемых примитивной рекурсией. Он дополнительно определил сложение, умножение и возведение в степень с помощью рекурсии, а затем методом индукции доказал, что указанные функции удовлетворяют ожидаемым алгебраическим уравнениям. Первые два из этих определений были даны Пеано (1889) для определения символов <span class="math notranslate nohighlight">\(+\)</span> и <span class="math notranslate nohighlight">\(\times\)</span> в аксиоматизации арифметики.</p>
<p><strong>Примитивно-рекурсивные функции.</strong>
Сколем провел первое исследование в 1920-х годах. Одной из его главных целей была разработка логической основы теории чисел, позволяющей избежать использования кванторов, таких как “для всех” (обозначается <span class="math notranslate nohighlight">\(\forall\)</span>) и “существует” (обозначается <span class="math notranslate nohighlight">\(\exists\)</span>). Его подход заключался в представлении математических теорем в виде функциональных утверждений. Вместо того, чтобы записывать <span class="math notranslate nohighlight">\((\forall x)(\forall y)( x + y = y + x )\)</span>, Сколем мог выразить эту идею в виде уравнения (тождества) между двумя функциями или выражениями, как в уравнении:</p>
<p><span class="math notranslate nohighlight">\(x + y = y + x\)</span></p>
<p>Эти тождества, позже названные Гильбертом и Бернайсом (1934) “поддающимися проверке”, могут быть проверены путем вычисления отдельных примеров. Это делается путем замены переменных в инструкции фактическими числами и проверки правильности инструкции на основе примитивных, простых, пошаговых вычислений, которые можно применять многократно. Сколем описал этот процесс пошагового определения математических функций и свойств, который можно проверить с помощью вычислений, как рекурсивный способ мышления. Он неформально описал четыре особенности этой системы.</p>
<ol class="arabic simple">
<li><p>Натуральные числа и функция следования: Система начинается с натуральных чисел, 0, 1, 2 и т.д., в качестве базовых объектов вместе с функцией следования <span class="math notranslate nohighlight">\(x + 1\)</span>, которая выдает следующее число.</p></li>
<li><p>Замена описаний функций: Если две функции равны, вы можете заменить одну на другую в разных выражениях.</p></li>
<li><p>Определения с помощью рекурсии: все функции или родственники натуральных чисел определяются рекурсивно.</p></li>
<li><p>Доказательство утверждений с помощью индукции: Функциональные утверждения (т.е. математические теоремы, такие как коммутативность сложения) доказываются с помощью математической индукции.</p></li>
</ol>
<p>Сколем использовал эти принципы, чтобы дать рекурсивные определения основных функций, таких как предшествование и вычитание, отношений, включая сравнение, делимость, отношения простоты, наибольшие общие делители и наименьшие общие кратные. По сути, работа Сколема содержала неформальное описание того, что мы сейчас называем примитивно-рекурсивными функциями, и он изучал, как рекурсивная определимость связана с эффективной вычислимостью.</p>
<p>Следующей важной вехой в развитии теории рекурсивных функций является формальное описание примитивно-рекурсивных функций. Этот прогресс в значительной степени обусловлен работой над программой Гильберта, а также доказательством теоремы Гёделя о неполноте.</p>
<p>Хотя программа Гильберта была амбициозной и ставила своей целью обеспечить надежную основу для всей математики, первоначально она была сосредоточена на доказательстве непротиворечивости арифметики (1900). План проведения такого доказательства был описан с точки зрения финитности. Идея заключалась в том, что если бы все математические рассуждения можно было свести к конечностным операциям, то можно было бы обеспечить непротиворечивость математики на прочном фундаменте. Гильберт полагал, что абстрактные и потенциально бесконечные концепции можно свести к конечным, надежным рассуждениям с помощью этого конечностного метода. С этой целью он предложил использовать метод, который он назвал метаматематикой, для доказательства непротиворечивости формальной математической системы (или теории).</p>
<p>В рамках своих усилий по развитию метаматематики в 1910-х и 1920-х годах Гильберт в сотрудничестве с Аккерманом и Бернайсом предложил использовать “числовые знаки” для представления натуральных чисел и описания контекстуальной индукции. Идея состояла в том, чтобы рассматривать числа не как абстрактные сущности, а как конкретные, конечные последовательности физических комбинаторных объектов. Цифровые знаки обычно представлялись в виде простых символов или штрихов (например, “|”, “||”, “|||”), которые непосредственно соответствуют натуральным числам (1, 2, 3 и т.д.). С такими выражениями можно работать конкретно, соединяя или удаляя штрихи, отражая арифметические операции последователя и предшественника, описанные в рекурсивном режиме мышления. Гильберт также использует эту идею для объяснения смысла функциональных утверждений типа коммутативности сложения. Их можно доказать, обратившись к тому, как они определяются рекурсивно, используя логические выводы.</p>
<p>Гильберт продолжил разработку логического исчисления для теории конечных чисел, которое включало “рекурсию и интуитивную индукцию для конечных совокупностей”. Он впервые дал определение одновременной рекурсии, которое указывало на то, что позже будет названо рекурсивными схемами. Он и его коллеги продолжили изучение этой системы рекурсивных определений и описали несколько типов рекурсии.</p>
<ul class="simple">
<li><p>обычная рекурсия, которая имеет простую структуру и похожа на описание примитивной рекурсии, данное Сколемом;</p></li>
<li><p>трансфинитная рекурсия, которая распространяется на бесконечные последовательности;</p></li>
<li><p>рекурсия высших типов, где схемы рекурсии применяются не только к числам, но и к более абстрактным объектам, таким как сами функции.</p></li>
</ul>
<p>Однако этот существенный вклад Гильберта и его сотрудников в рекурсивную определимость и их влияние позже затмила более точная формулировка примитивной рекурсии, данная Гёделем, которая стала краеугольным камнем современной теории рекурсии. Гёдель усовершенствовал описания своих предшественников и дал формальное определение того, что такое рекурсивно определенные функции.</p>
<p><u>Определение.</u> Числовая функция <span class="math notranslate nohighlight">\(\varphi(x_1, \ldots, x_n)\)</span> определена рекурсивно с помощью числовых функций <span class="math notranslate nohighlight">\(\psi(x_1, \ldots, x_{n-1})\)</span> и <span class="math notranslate nohighlight">\(\mu(x_1, \ldots, x_{n+1})\)</span>, если для любых значений <span class="math notranslate nohighlight">\(x_1, \ldots, x_n\)</span> и <span class="math notranslate nohighlight">\(k\)</span> выполняются следующие уравнения:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(\varphi(0, x_2, \ldots, x_n) = \psi(x_2, \ldots, x_n)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\varphi(k+1, \ldots, x_n) = \mu(k, \varphi(k, \ldots, x_n)), x_2, \ldots, x_n)\)</span></p></li>
</ol>
<p>Числовая функция <span class="math notranslate nohighlight">\(\varphi\)</span> называется рекурсивной, если существует конечная последовательность числовых функций <span class="math notranslate nohighlight">\(\varphi_1, \ldots, \varphi_n\)</span>, которая заканчивается на функции <span class="math notranslate nohighlight">\(\varphi\)</span>, такая, что каждая функция в этой последовательности:</p>
<ul class="simple">
<li><p>константа или функция следования</p></li>
<li><p>или рекурсивно определена через две предшествующие ей функции</p></li>
<li><p>или результат подстановки в одну из предшествующих функций.</p></li>
</ul>
<p>Это определение дало математически определенный класс функций над натуральными числами, теперь известный как примитивно-рекурсивные функции, хотя Гёдель использовал только термин “рекурсивный”.</p>
<p>Гёдель перешел к определению примитивно-рекурсивных отношений, которые он назвал рекурсивными отношениями, используя характеристические функции.</p>
<p><u>Определение.</u> Отношение <span class="math notranslate nohighlight">\(R(x_1, \ldots, x_n)\)</span> между натуральными числами называется рекурсивным, если существует примитивно-рекурсивная функция <span class="math notranslate nohighlight">\(\varphi(x_1, \ldots, x_n)\)</span>, такая, что для любых значений <span class="math notranslate nohighlight">\(x_1, \ldots, x_n\)</span> выполняется
<span class="math notranslate nohighlight">\(R(x_1, \ldots, x_n) \leftrightarrow (\varphi(x_1, \ldots, x_n) = 0)\)</span></p>
<p>Гёдель доказал, что эти примитивно-рекурсивные отношения обладают важными свойствами замыкания. Они замкнуты относительно логических операций и относительно применения кванторов общности и существования в диапазоне, ограниченном примитивной рекурсивной функцией.</p>
<p><strong>Гёделевское определение рекурсии и его теорема о неполноте.</strong> Основной целью его знаменитой статьи 1931 года было доказать его теорему о неполноте, которая гласит, что если арифметическая система непротиворечива, то существует формула, которая неразрешима внутри системы – это означает, что ее нельзя ни доказать, ни опровергнуть с помощью аксиом системы. Он впервые разработал формальную логическую систему, которую назвал <span class="math notranslate nohighlight">\(\mathbf P\)</span>, на основе труда “Principia Mathematica” Рассела и Уайтхеда (1910-1913). Затем у него возникла идея получить такую неразрешимую формулу в <span class="math notranslate nohighlight">\(\mathbf P\)</span> из соображения, что рекурсивные определения естественным образом связаны с индуктивными определениями синтаксических структур правильно построенных формул и доказательств.</p>
<p>Затем Гёдель разработал технику, известную как арифметизация синтаксиса, для выражения формул и доказательств в виде примитивно-рекурсивных отношений, и он показал, что для каждого примитивно-рекурсивного отношения <span class="math notranslate nohighlight">\(R(x_1, \ldots, x_k)\)</span> существует формула <span class="math notranslate nohighlight">\(\varphi_R( x_1, \ldots , x_k )\)</span> из <span class="math notranslate nohighlight">\(\mathbf P\)</span>, такая, что факт, который содержится (или не содержится) в данной последовательности чисел <span class="math notranslate nohighlight">\(n_1, \ldots, n_k\)</span>, отражается доказуемостью (или опровержимостью) в <span class="math notranslate nohighlight">\(\mathbf P\)</span> соответствующего экземпляра <span class="math notranslate nohighlight">\(\varphi_R ( x_1, \ldots , x_k )\)</span>. Пусть <span class="math notranslate nohighlight">\(\overline{n} = s (\ldots( s (0))) \)</span> - это формальное представление числа <span class="math notranslate nohighlight">\(n\)</span> в <span class="math notranslate nohighlight">\(\mathbf P\)</span> путем применения <span class="math notranslate nohighlight">\(n\)</span> раз функции следования <span class="math notranslate nohighlight">\(s( x )\)</span> к <span class="math notranslate nohighlight">\(0\)</span>. Тогда, формально говоря, выполняются свойства:</p>
<ol class="arabic simple">
<li><p>если выполняется <span class="math notranslate nohighlight">\(R(n_1, \ldots, n_k)\)</span>, то <span class="math notranslate nohighlight">\(\mathbf P \vdash \varphi_R(\overline{n_1}, \ldots, \overline{n_k})\)</span></p></li>
<li><p>если не выполняется <span class="math notranslate nohighlight">\(R(n_1, \ldots, n_k)\)</span>, то <span class="math notranslate nohighlight">\(\mathbf P \vdash \neg\varphi_R(\overline{n_1}, \ldots, \overline{n_k})\)</span></p></li>
</ol>
<p>Затем Гёдель установил, что формула <span class="math notranslate nohighlight">\(\varphi_R(x_1, \ldots, x_k)\)</span> представляет отношение <span class="math notranslate nohighlight">\(R(x_1, \ldots, x_k)\)</span>, и ввел формулу для представления функции. Функция <span class="math notranslate nohighlight">\(f(x_1, \ldots, x_k)\)</span> представима в <span class="math notranslate nohighlight">\(\mathbf P\)</span>, если существует формула <span class="math notranslate nohighlight">\(\varphi_f(x_1, \ldots, x_k, y)\)</span>, такая, что для любых чисел <span class="math notranslate nohighlight">\(n_1, \ldots, n_k\)</span>, а также числа <span class="math notranslate nohighlight">\(m\)</span>:</p>
<p><span class="math notranslate nohighlight">\(f(n_1, \ldots, n_k) = m\)</span>, если и только если <span class="math notranslate nohighlight">\(\mathbf P \vdash \varphi_f(n_1, \ldots, n_k, m)\)</span>.</p>
<p>Полученное уравнение выражает взаимосвязь между представимости функции в формальной системе и ее вычислимостью.</p>
<p>Затем Гедель предложил метод кодирования каждого символа в алфавите, терма, формулы и доказательства, обозначаемого <span class="math notranslate nohighlight">\(\alpha\)</span>, в виде уникального натурального числа <span class="math notranslate nohighlight">\([\alpha]\)</span>, основанного на их индуктивных структурах. Число <span class="math notranslate nohighlight">\([\alpha]\)</span> теперь называется гёделевским номером строки <span class="math notranslate nohighlight">\(\alpha\)</span>. В этой системе кодирования индуктивные синтаксические операции в синтаксических элементах соответствуют операциям с гёделевскими номерами, которые могут быть описаны с помощью примитивно-рекурсивных функций. Например, предположим, что <span class="math notranslate nohighlight">\(x\)</span> - это гёделевский номер формулы <span class="math notranslate nohighlight">\(\varphi\)</span>, функция <span class="math notranslate nohighlight">\(\neg x\)</span>, которая возвращает гёделевский номер формулы <span class="math notranslate nohighlight">\((\neg \varphi)\)</span>, может быть задана как <span class="math notranslate nohighlight">\([\neg] * x\)</span>. Этот метод кодирования можно понимать как обобщение “конструирования и деконструирования числовых знаков”, описанного Гильбертом.</p>
<p>Важным шагом в получении формулы, неразрешимой в <span class="math notranslate nohighlight">\(\mathbf P\)</span>, было определить связь <span class="math notranslate nohighlight">\(Proof(x,y)\)</span>, которая имеет место для гёделевского номера числа <span class="math notranslate nohighlight">\(x\)</span> и номера <span class="math notranslate nohighlight">\(y\)</span> последовательности формул <span class="math notranslate nohighlight">\(\varphi_1, \ldots, \varphi_n\)</span>, если и только если последовательность <span class="math notranslate nohighlight">\(\varphi_1, \ldots, \varphi_n\)</span> - это доказательство формулы <span class="math notranslate nohighlight">\(\varphi\)</span> в <span class="math notranslate nohighlight">\(\mathbf P\)</span>:</p>
<p><span class="math notranslate nohighlight">\(Proof([\varphi], [\varphi_1, \ldots, \varphi_n]) \text{ если и только если } \vdash_{\mathbf P} \text{ с док-вом } \varphi_1, \ldots, \varphi_n\)</span></p>
<p>Согласно определению отношения <span class="math notranslate nohighlight">\(R\)</span>, существует формула <span class="math notranslate nohighlight">\(WfPrf(x, y)\)</span>, которая представляет отношение <span class="math notranslate nohighlight">\(Proof(x, y)\)</span>, и поэтому можно определить формулу <span class="math notranslate nohighlight">\((\exists y) WfPrf(x,y)\)</span>, обозначаемую <span class="math notranslate nohighlight">\(Proof(x)\)</span>. Формула <span class="math notranslate nohighlight">\(Proof(x)\)</span> выражает следующее утверждение: существует доказательство в <span class="math notranslate nohighlight">\(\mathbf P\)</span> теоремы <span class="math notranslate nohighlight">\(\varphi\)</span> с гёделевским номером <span class="math notranslate nohighlight">\(x\)</span>.</p>
<p>Финальный шаг Гёделя в конструировании неразрешимой формулы - доказательство леммы о диагонали, которая утверждает, что для всякой формулы <span class="math notranslate nohighlight">\(\varphi(x)\)</span> системы <span class="math notranslate nohighlight">\(\mathbf P\)</span> существует замкнутая формула <span class="math notranslate nohighlight">\(\psi_\varphi\)</span>, такая, что</p>
<p><span class="math notranslate nohighlight">\(\vdash_{\mathbf P} \psi_\varphi \leftrightarrow \varphi(\overline{[\psi_{\varphi}]})\)</span></p>
<p>Формула <span class="math notranslate nohighlight">\(\psi_\varphi\)</span> называется гёделевской последовательностью формулы <span class="math notranslate nohighlight">\(\varphi\)</span>. Затем он применил эту лемму к формуле <span class="math notranslate nohighlight">\(\neg Proof(x)\)</span> и получил гёделевскую последовательность, обозначаемую <span class="math notranslate nohighlight">\(\mathbf G_{\mathbf P}\)</span>, такую, что</p>
<p><span class="math notranslate nohighlight">\(\vdash_{\mathbf P} \mathbf G_{\mathbf P} \leftrightarrow \neg Proof(\overline{[\mathbf G_{\mathbf P}]})\)</span></p>
<p>Интуитивно можно сказать, что формула <span class="math notranslate nohighlight">\(\mathbf G_{\mathbf P}\)</span> утверждает свою же недоказуемость в рамках системы <span class="math notranslate nohighlight">\(\mathbf P\)</span>. Гёдель доказал, что ни эта формула, ни её отрицание недоказуемы в <span class="math notranslate nohighlight">\(\mathbf P\)</span>, формально установив, что:</p>
<ul class="simple">
<li><p>если <span class="math notranslate nohighlight">\(\mathbf P\)</span> непротиворечива, то <span class="math notranslate nohighlight">\(\nvdash_{\mathbf P} \mathbf G_{\mathbf P}\)</span>;</p></li>
<li><p>если <span class="math notranslate nohighlight">\(\mathbf P\)</span> является <span class="math notranslate nohighlight">\(\omega\)</span>-непротиворечивой, то <span class="math notranslate nohighlight">\(\nvdash_{\mathbf P} \neg\mathbf G_{\mathbf P}\)</span>.</p></li>
</ul>
<p>Теперь это утверждение известно как первая теорема Гёделя о неполноте. В доказательстве своей теоремы Гёдель построил в явном виде представимость отношения <span class="math notranslate nohighlight">\(Proof(x, y)\)</span> в <span class="math notranslate nohighlight">\(\mathbf P\)</span>, которая в свою очередь вытекает из своего примитивно-рекурсивного определения.</p>
<p><strong>Примитивно-рекурсивные функции и проблема разрешимости Гильберта-Аккермана.</strong>
Другой мотивацией для работы над рекурсивными функциями в 1930-х годах было изучение неразрешимых проблем. Это включало определение того, является ли данная формула логики первого порядка общезначимой. Задача была впервые сформулирована как Entscheidungsproblem (или проблема разрешимости) для логической системы первого порядка, приведенной Гильбертом и Аккерманом, которая теперь известна как аксиоматическая система Гильберта.</p>
<p>Основная проблема заключается в том, существует ли процедура, которая может определить для каждой правильно построенной формулы системы, удовлетворяет ли она всем интерпретациям. Из теоремы, касающейся адекватности системы Гильберта, следует, что формула верна тогда и только тогда, когда она является теоремой системы. Таким образом, проблема разрешимости эквивалентна разрешимости логической выводимости в системе. По сути, это касается возможности алгоритмического поиска доказательств, чтобы определить, является ли формула логическим следствием формальной системы.</p>
<p>В 1936 году Черч и Тьюринг доказали несколько отрицательных результатов, касающихся проблемы разрешимости. Их работа считается основополагающей в развитии эффективной вычислимости, главным образом благодаря их определению примитивно-рекурсивных функций как класса эффективно вычислимых функций. Все результаты были основаны на построении неразрешимого множества натуральных чисел <span class="math notranslate nohighlight">\(V\)</span>, которое состоит из чисел Геделя в допустимых формулах. Множество <span class="math notranslate nohighlight">\(V\)</span> неразрешимо, поскольку его характеристическая функция не является примитивно-рекурсивной.</p>
<p><strong>Функция Аккермана: за рамками примитивно рекурсивных функций.</strong>
Примитивно–рекурсивные функции считаются полностью вычислимыми, поскольку их значения для заданных входных данных могут быть систематически вычислены шаг за шагом с помощью рекурсии на основе определяющих выражений - аналогично тому, как формальное доказательство выполняется путем последовательных логических выводов. Однако теперь мы знаем, что существуют функции, значения которых все еще могут быть вычислены рекурсивно, но не классифицируются как примитивно-рекурсивные функции. Еще в конце 1920-х годов Гильберт и его коллеги осознали это ограничение и начали изучать то, что сейчас известно как общерекурсивные функции.</p>
<p>Сколем и Гильберт впервые предложили рекурсию высших типов, используя функционалы для определения рекурсивных функций. Одним из примеров является итерационный функционал <span class="math notranslate nohighlight">\(Iter\)</span>, который принимает функцию <span class="math notranslate nohighlight">\(f\)</span> типа <span class="math notranslate nohighlight">\(\mathbb N \to \mathbb N\)</span> и число <span class="math notranslate nohighlight">\(i\)</span> и возвращает значение функции <span class="math notranslate nohighlight">\(f\)</span>,  примененной к самой себе <span class="math notranslate nohighlight">\(i\)</span> раз. Формально <span class="math notranslate nohighlight">\(Iter\)</span> - это функционал типа <span class="math notranslate nohighlight">\((\mathbb N \to \mathbb N) \to (\mathbb N \to \mathbb N)\)</span>. Он принимает функцию на <span class="math notranslate nohighlight">\(\mathbb N\)</span> и возвращает функцию на <span class="math notranslate nohighlight">\(\mathbb N\)</span>, которая определяется так:</p>
<p><span class="math notranslate nohighlight">\(Iter(f, 0) = Id, \quad Iter(f, i+1) = f \circ Iter(f, i)\)</span></p>
<p>где <span class="math notranslate nohighlight">\((f \circ g)(x) = f(g(x))\)</span>.
Таким образом, <span class="math notranslate nohighlight">\(Iter(f, i)\)</span> представляет собой <span class="math notranslate nohighlight">\(f^{(i)}\)</span>, то есть функцию <span class="math notranslate nohighlight">\(f\)</span>, примененную к себе <span class="math notranslate nohighlight">\(i\)</span> раз.</p>
<p>Теперь мы можем использовать функционал <span class="math notranslate nohighlight">\(Iter\)</span>, чтобы определить функцию <span class="math notranslate nohighlight">\(\beta\)</span> типа <span class="math notranslate nohighlight">\(\mathbb N \mapsto (\mathbb N \mapsto \mathbb N)\)</span> “рекурсивно”:</p>
<p><span class="math notranslate nohighlight">\(\beta(0) = s, \quad \beta(i+1) = Iter(\beta(i), x)(\beta(i)(1))\)</span></p>
<p>Здесь <span class="math notranslate nohighlight">\(s\)</span> - это функция следования, т.е. <span class="math notranslate nohighlight">\(s(x) = x + 1\)</span>. Например, <span class="math notranslate nohighlight">\(\beta(0)(1) = 2\)</span>, и <span class="math notranslate nohighlight">\(\beta(2)\)</span> - это функция <span class="math notranslate nohighlight">\(s^{(x)}(2) = s \circ s\)</span>. Поэтому <span class="math notranslate nohighlight">\(\beta(2)(5) = 7\)</span>. В общем случае можем записать <span class="math notranslate nohighlight">\(\beta(i)(j)\)</span> как двухместную функцию <span class="math notranslate nohighlight">\(\pi(x, y)\)</span>, которая называется функцией Петер (или <a class="reference external" href="https://plato.stanford.edu/entrieS/recursive-functions/ackermann-peter.html">функцией Аккермана-Петер</a>). Несмотря на то, что для <span class="math notranslate nohighlight">\(i = 0, 1, \ldots\)</span> функция <span class="math notranslate nohighlight">\(\pi(i, y)\)</span> является вычислимой, она растет крайне быстро и выпадает из класса примитивно рекурсивных функций.</p>
<p>Позднее Аккерман определил функцию, эквивалентную <span class="math notranslate nohighlight">\(\pi(x, y)\)</span>, используя рекурсию непосредственно на натуральных числах. Петер и Робинсон упростили ее, и сейчас она называется функцией Аккермана:</p>
<p><span class="math notranslate nohighlight">\(ACK(0, y) = y + 1\)</span></p>
<p><span class="math notranslate nohighlight">\(ACK(x+1, 0) = ACK(x, 1)\)</span></p>
<p><span class="math notranslate nohighlight">\(ACK(x+1, y+1) = ACK(x+1, ACK(x,y))\)</span></p>
<p>Аккерман назвал это определение одновременной рекурсией. Третий шаг определяет <span class="math notranslate nohighlight">\(ACK(x+1, y+1)\)</span> через <span class="math notranslate nohighlight">\(ACK(x,y)\)</span>, что приводит к “вложенным вызовам функции”. Не сразу видно, что эта рекурсия завершается, но по мере уменьшения <span class="math notranslate nohighlight">\(y\)</span> или когда <span class="math notranslate nohighlight">\(y\)</span> достигает <span class="math notranslate nohighlight">\(0\)</span>, <span class="math notranslate nohighlight">\(x\)</span> начинает уменьшаться, гарантируя, что процесс в конечном итоге завершится. Таким образом, несмотря на свой быстрый рост, функция Аккермана все еще вычислима за конечное число шагов, удовлетворяя требованию Гёделя о том, чтобы рекурсивно определенная функция была вычислима с помощью конечной процедуры.</p>
<p>Интерес к рекурсивным функциям, выходящим за рамки класса примитивно-рекурсивных функций, привел к систематическому изучению рекурсии. Термин “примитивно-рекурсивный” был впервые введен Петер в 1932 году, когда она использовала его для описания функций, определенных в уравнении Геделя. Этот термин стал стандартным после того, как был принят Клини в 1936 году.</p>
<p>Петер также показала, что множество примитивно-рекурсивных функций замкнуто относительно рекурсии по ходу значений, множественной рекурсии и вложенной рекурсии по одной переменной. Это продемонстрировало богатство класса примитивно-рекурсивных функций. Это также подтвердило, что функции, подобные функции Аккермана, хотя и имеют более сложные вычислительные процессы, по-прежнему являются рекурсивными, но не относятся к классу примитивно-рекурсивных.</p>
<p><strong>Общерекурсивные функции.</strong>
В 1930-х годах Гедель и Эрбран исследовали использование уравнений и подстановки в качестве общего способа описания рекурсии. Этот метод рассматривает вычисление функций как вывод в логике первого порядка без кванторов, где единственными допустимыми правилами являются замена переменных числами (нумералами) и замена термов в уравнениях числами, когда соответствующее тождество уже выведено. Гедель использовал термин “общерекурсивная” для обозначения функции, определенной таким образом. Теперь мы определяем рекурсивные системы, используя следующие синтаксические правила:</p>
<p><u>Определение.</u></p>
<ol class="arabic simple">
<li><p>Класс <em>чисел</em> <span class="math notranslate nohighlight">\(Nat\)</span> - это наименьшее множество, такое, что (1) оно содержит <span class="math notranslate nohighlight">\(0\)</span> и (2) если <span class="math notranslate nohighlight">\(\overline{n} \in Nat\)</span>, то <span class="math notranslate nohighlight">\(s(\overline{n}) \in Nat\)</span>. Здесь <span class="math notranslate nohighlight">\(\overline{n}\)</span> обозначает <span class="math notranslate nohighlight">\(s(s(\ldots s(0)))\)</span> (<span class="math notranslate nohighlight">\(n\)</span> раз).</p></li>
<li><p>Класс <em>термов</em> <span class="math notranslate nohighlight">\(Term\)</span> - это наименьшее множество, такое, что (а) оно содержит числа из <span class="math notranslate nohighlight">\(Nat\)</span> и переменные <span class="math notranslate nohighlight">\(x_0, x_1, \ldots\)</span>, (б) если <span class="math notranslate nohighlight">\(t \in Term\)</span>, то <span class="math notranslate nohighlight">\(s(t) \in Term\)</span>, (в) если <span class="math notranslate nohighlight">\(t_1, \ldots, t_n \in Term\)</span>, то <span class="math notranslate nohighlight">\(\psi^n(t_1, \ldots, t_n) \in Term\)</span> для любой <span class="math notranslate nohighlight">\(n\)</span>-местной примитивно рекурсивной функции.</p></li>
<li><p>Если <span class="math notranslate nohighlight">\(u\)</span> - это терм и <span class="math notranslate nohighlight">\(t\)</span> - это терм вида <span class="math notranslate nohighlight">\(\psi^n(t_1, \ldots, t_n)\)</span>, где каждый терм <span class="math notranslate nohighlight">\(t_i\)</span> не содержит функциональных символов кроме <span class="math notranslate nohighlight">\(s\)</span>, то <span class="math notranslate nohighlight">\(t = u\)</span> - это <em>уравнение</em>.</p></li>
<li><p><em>Система уравнений</em> - это конечное множество уравнений. Через <span class="math notranslate nohighlight">\(\mathcal E(\psi_1, \ldots, \psi_n, \vec x)\)</span> обозначаем систему уравнений с функциональными символами <span class="math notranslate nohighlight">\(\psi_1, \ldots, \psi_n\)</span> и переменными <span class="math notranslate nohighlight">\(\vec x = x_1, \ldots, x_k\)</span>.</p></li>
</ol>
<p>Эрбран дал семантическую характеристику того, что означает определение числовой функции системой уравнений, которую Гедель позже формализовал как определение общерекурсивных функций.</p>
<p><u>Определение.</u> Функция <span class="math notranslate nohighlight">\(f \colon \mathbb N^k \to \mathbb N\)</span> называется <em>общерекурсивной функцией</em>, если существует система уравнений <span class="math notranslate nohighlight">\(\mathcal E(\psi_1, \ldots, \psi_n, \vec x)\)</span> такая, что, если <span class="math notranslate nohighlight">\(\psi_i^k\)</span> - функциональный символ в левой части последнего уравнения в <span class="math notranslate nohighlight">\(\mathcal E\)</span>, то для всех значений <span class="math notranslate nohighlight">\(n_1, \ldots, n_k\)</span> и <span class="math notranslate nohighlight">\(m\)</span>:</p>
<p><span class="math notranslate nohighlight">\(f(n_1, \ldots, n_k) = m\)</span></p>
<p>тогда и только тогда, когда</p>
<p><span class="math notranslate nohighlight">\(\psi_i^k(\overline{n_1}, \ldots, \overline{n_k}) = \overline{m}\)</span></p>
<p>выводимо из <span class="math notranslate nohighlight">\(\mathcal E\)</span> по следующим правилам:</p>
<ul class="simple">
<li><p>Подстановка числа <span class="math notranslate nohighlight">\(\overline{n}\)</span> вместо любой переменной в уравнении.</p></li>
<li><p>Если <span class="math notranslate nohighlight">\(\psi_j^l(\overline{n_1}, \ldots, \overline{n_l}) = \overline{q}\)</span> выведено, то <span class="math notranslate nohighlight">\(\psi_j^l(\overline{n_1}, \ldots, \overline{n_l})\)</span> можно заменить на число <span class="math notranslate nohighlight">\(\overline{q}\)</span> в правой части уравнения.</p></li>
</ul>
<p>В этом случае <span class="math notranslate nohighlight">\(\mathcal E\)</span> определяет <span class="math notranslate nohighlight">\(f\)</span> через <span class="math notranslate nohighlight">\(\psi_i^k\)</span>.</p>
<p>Это определение показывает, что значения общерекурсивных функций могут быть механически вычислены с использованием систем рекурсивных уравнений в качестве этапов логического вывода. Теперь известно, что при такой формальной семантической характеристике функция Аккермана-Петер и другие функции, определенные схемами, рассмотренными Гильбертом, а также все примитивно-рекурсивные функции могут быть определены общими системами рекурсивных уравнений. Следовательно, класс <span class="math notranslate nohighlight">\(\mathbf {GR}\)</span>, определенный таким образом, образует собственный суперкласс класса примитивно-рекурсивных функций <span class="math notranslate nohighlight">\(\mathbf {PR}\)</span>.</p>
<p>Однако серьезная проблема заключается в том, что система уравнений может быть противоречивой, например <span class="math notranslate nohighlight">\(\{\varphi(x) = 0, \; \varphi(x) = s(0)\}\)</span> и не иметь решения, в то время как некоторые другие, такие как <span class="math notranslate nohighlight">\(\{\varphi x = \varphi x\}\)</span>, могут иметь более одного решения.</p>
<p><strong>Рекурсивные функции и теория вычислимости.</strong>
Работа над рекурсией, представленная до сих пор, является главным образом частью математической логики, направленной на создание основ математики, изложенных в программе Гильберта, в частности, касающихся арифметики. Это послужило основой для разработки теории рекурсивных функций в конце 1930-х годов, пионерами которой были Клини, Тьюринг, Черч и Пост. Ключевой темой в этой разработке является переход от метатеорий систем формальной логики к характеристике эффективной вычислимости. По этой причине современным термином для теории рекурсивных функций теперь является теория вычислимости, а рекурсивные функции обычно называют вычислимыми функциями.</p>
<p>Эффективная вычислимость отражает нашу интуицию в отношении алгоритмической вычислимости. Она поддерживает строгие доказательства, абстрагируясь от деталей моделей, таких как общерекурсивные функции Геделя. Позже Клини предложил определение частично рекурсивных функций с использованием оператора неограниченной минимизации, который заменил общерекурсивные уравнения Геделя, принятые в качестве стандарта. Позже это было заменено машинными определениями, такими как определение Тьюринга, которые напоминают современные компьютерные программы. Тем не менее, эти новые характеристики все еще сохраняли идею о вычислениях как об эффективных процессах в рамках “рекурсивного способа мышления”, как это понимали ранние математики и логики, такие как Сколем, Гильберт, Гедель и Петер. В дальнейшем мы введем определения различных замкнутых классов рекурсивных функций.</p>
<p>Во-первых, любой класс <span class="math notranslate nohighlight">\(\mathbf X\)</span> рекурсивных функций определяется на основе набора начальных функций <span class="math notranslate nohighlight">\(\mathbf I_{\mathbf X}\)</span>. Для класса примитивных рекурсивных функций <span class="math notranslate nohighlight">\(\mathbf{PR}\)</span> начальные функции <span class="math notranslate nohighlight">\(\mathbf{I_{PR}}\)</span> включают константу <span class="math notranslate nohighlight">\(0\)</span>, функцию следования <span class="math notranslate nohighlight">\(s\)</span> и проекционные функции <span class="math notranslate nohighlight">\(\pi_i^k \colon \mathbb N^k \mapsto \mathbb N\)</span>, которые определяются для каждого <span class="math notranslate nohighlight">\(i\)</span> и <span class="math notranslate nohighlight">\(k\)</span> по формуле</p>
<p><span class="math notranslate nohighlight">\(\pi_i^k(x_1, \ldots, i, \ldots, x_k) = x_i\)</span></p>
<p>Затем примитивно рекурсивные функции определяются через функционалы, называемые композицией (суперпозицией) и примитивной рекурсией.</p>
<p><u>Определение.</u> Операторы суперпозиции и примитивной рекурсии определяются следующим образом.</p>
<ul class="simple">
<li><p>Для любых натуральных чисел <span class="math notranslate nohighlight">\(l\)</span> и <span class="math notranslate nohighlight">\(k\)</span> <em>оператор суперпозиции</em> <span class="math notranslate nohighlight">\(Comp_k^l\)</span> принимает заданные функции <span class="math notranslate nohighlight">\(f \colon \mathbb N^l \mapsto \mathbb N\)</span> и <span class="math notranslate nohighlight">\(g_1, \ldots, g_l \colon \mathbb N^k \mapsto \mathbb N\)</span> и возвращает функцию <span class="math notranslate nohighlight">\(Comp_k^l[f, g_1, \ldots, g_l] \colon \mathbb N^k \mapsto N\)</span>, определяемую формулой</p></li>
</ul>
<p><span class="math notranslate nohighlight">\(Comp_k^l(f, g_1, \ldots, g_l)(x_0, \ldots, x_k) = f(g_1(x_1, \ldots, x_k), \ldots, g_l(x_1, \ldots, x_k))\)</span></p>
<ul class="simple">
<li><p>Для любых натуральных чисел <span class="math notranslate nohighlight">\(k\)</span> <em>оператор примитивной рекурсии</em> <span class="math notranslate nohighlight">\(PrimR_k^l\)</span> принимает на вход функции <span class="math notranslate nohighlight">\(f \colon \mathbb N^k \mapsto \mathbb N\)</span> и <span class="math notranslate nohighlight">\(g \colon \mathbb N^{k+2} \mapsto \mathbb N\)</span> и возвращает функцию <span class="math notranslate nohighlight">\(PrimR_k[f, g] \colon \mathbb N^{k+1} \mapsto \mathbb N\)</span>, такую, что</p></li>
</ul>
<p><span class="math notranslate nohighlight">\(PrimR_k[f,g](x_1, \ldots, x_k, 0) = f(x_1, \ldots, x_k)\)</span></p>
<p><span class="math notranslate nohighlight">\(PrimR_k[f, g](x_1, \ldots, x_k, y+1) = g(x_1, \ldots, x_k, y, PrimR_k[f,g](x_1, \ldots, x_k, y)\)</span></p>
<p>Введем формальные определения примитивно рекурсивных функций и примитивно рекурсивных отношений.</p>
<p><u>Определение.</u> Класс <em>примитивно рекурсивных функций</em> <span class="math notranslate nohighlight">\(\mathbf{PR}\)</span> - это наименьший класс функций, содержащий начальные функции <span class="math notranslate nohighlight">\(\mathbf{I_{PR}} = \{0, s, \pi_i^k \colon i, k \in \mathbb N\}\)</span> и замкнутый относительно операторов <span class="math notranslate nohighlight">\(Op_{\mathbf{PR}} = \{Comp_k^l, PrimR_j \colon k, l, j \in \mathbb N\}\)</span>.</p>
<p>Отношение <span class="math notranslate nohighlight">\(R \subset \mathbb N^k\)</span> - это <em>примитивно рекурсивное отношение</em>, если его характеристическая функция примитивно рекурсивна:</p>
<p><span class="math notranslate nohighlight">\(
\chi_R(x_1, \ldots, x_k) = \begin{cases} 1, &amp; \text{если выполняется }R(x_1, \ldots, x_k),\\
0, &amp; \text{если выполняется }\neg R(x_1, \ldots, x_k)
\end{cases}
\)</span></p>
<p>Следовательно, для рекурсивного отношения <span class="math notranslate nohighlight">\(R\)</span> существует алгоритм или механическая процедура, которая возвращает <span class="math notranslate nohighlight">\(1\)</span> на входе <span class="math notranslate nohighlight">\(\vec n\)</span>, если <span class="math notranslate nohighlight">\(R\)</span> выполняется для <span class="math notranslate nohighlight">\(\vec n\)</span>, и выдает <span class="math notranslate nohighlight">\(0\)</span>, если <span class="math notranslate nohighlight">\(R\)</span> не выполняется для <span class="math notranslate nohighlight">\(\vec n\)</span>.</p>
<p>Теперь класс <span class="math notranslate nohighlight">\(\mathbf{PR}\)</span> рекурсивных функций можно формально определить как минимальное замыкание множества <span class="math notranslate nohighlight">\(\mathbf I_{\mathbf{PR}}\)</span> относительно функций из <span class="math notranslate nohighlight">\(Op_{\mathbf {PR}}\)</span>.</p>
<p><u>Определение.</u> <em>Класс примитивно рекурсивных функций</em> <span class="math notranslate nohighlight">\(\mathbf{PR}\)</span> определяется как подкласс класса <span class="math notranslate nohighlight">\(\bigcup\limits_{k \in \mathbb N} (\mathbb N^k \mapsto \mathbb N)\)</span>, такой, что выполняются следующие свойства:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf I_{\mathbf{PR}} \subset \mathbf {PR}\)</span>;</p></li>
<li><p>Для <span class="math notranslate nohighlight">\(l, k \in \mathbb N\)</span> и <span class="math notranslate nohighlight">\(f, g_1, \ldots, g_l \in \mathbf{PR}\)</span>, если <span class="math notranslate nohighlight">\(f\)</span> - это <span class="math notranslate nohighlight">\(l\)</span>-арная функция и <span class="math notranslate nohighlight">\(g_i\)</span> - это <span class="math notranslate nohighlight">\(k\)</span>-арная (для <span class="math notranslate nohighlight">\(1 \leq i \leq l\)</span>), тогда <span class="math notranslate nohighlight">\(Comp_k^l[f, g_1 ,\ldots, g_l] \in \mathbf {PR}\)</span>;</p></li>
<li><p>Для всех <span class="math notranslate nohighlight">\(k \in \mathbb N\)</span> и любой <span class="math notranslate nohighlight">\(k\)</span>-арной функции <span class="math notranslate nohighlight">\(f\)</span> и любых <span class="math notranslate nohighlight">\((k+2)\)</span>-арных функций <span class="math notranslate nohighlight">\(g\)</span>, если <span class="math notranslate nohighlight">\(f, g \in \mathbf{PR}\)</span>, то <span class="math notranslate nohighlight">\(PrimR_k[f, g] \in \mathbf{PR}\)</span>.</p></li>
</ol>
<p>В современной математической логике язык формальных логических систем обычно определяется через свойства замыкания. Хорошо известно, что класс <span class="math notranslate nohighlight">\(\mathbf {PR}\)</span> является счетным, и каждый элемент в этом классе имеет алгоритмические спецификации для вычисления семантики функции. Задача программирования состоит в том, чтобы выразить вычислительную задачу в виде спецификации в рамках <span class="math notranslate nohighlight">\(\mathbf{PR}\)</span>. Кроме того, класс примитивно-рекурсивных отношений замкнут относительно базовых логических операций (логическими связями): отрицания (<span class="math notranslate nohighlight">\(\neg\)</span>), конъюнкции (<span class="math notranslate nohighlight">\(\land\)</span>) и дизъюнкции (<span class="math notranslate nohighlight">\(\vee\)</span>). Различные функции, определяемые различными свойствами замыкания, эквивалентны <span class="math notranslate nohighlight">\(\mathbf {PR}\)</span>.</p>
<p>Ранее мы видели, что функция Аккермана-Петер, построенная с помощью “рекурсии”, не является элементом класса <span class="math notranslate nohighlight">\(\mathbf {PR}\)</span>. Кроме того, известно, что множество всех функций над натуральными числами несчетно. Следовательно, должны существовать функции, которых нет в <span class="math notranslate nohighlight">\(\mathbf{PR}\)</span>.</p>
<p>Другой способ понять существование непримитивных рекурсивных функций - это любое перечисление <span class="math notranslate nohighlight">\(\mathbf {PR}\)</span>, скажем, <span class="math notranslate nohighlight">\(f_0\)</span>, <span class="math notranslate nohighlight">\(f_1\)</span>, <span class="math notranslate nohighlight">\(f_2\)</span>, … Для перечисления мы можем определить функцию <span class="math notranslate nohighlight">\(g\)</span> таким образом, что <span class="math notranslate nohighlight">\(g (n) = f_n (n) + 1\)</span>. Используя метод диагонализации, можно показать, что <span class="math notranslate nohighlight">\(g (n)\)</span> не является элементом <span class="math notranslate nohighlight">\(\mathbf{PR}\)</span>. Это показывает, что существуют интуитивно эффективные процедуры для вычисления такой функции <span class="math notranslate nohighlight">\(g\)</span>. Задача состоит в том, чтобы определить класс “общих” функций, которые расширяют <span class="math notranslate nohighlight">\(\mathbf {PR}\)</span>, сохраняя при этом четко определенные свойства замыкания. Это достигается с помощью <em>оператора минимизации</em> (<span class="math notranslate nohighlight">\(µy\)</span>). Для любой <span class="math notranslate nohighlight">\((k + 1)\)</span>-арной частичной функции <span class="math notranslate nohighlight">\(f\)</span> мы определяем выражения вида <span class="math notranslate nohighlight">\((\mu y ) f( x_1, \ldots , x_k, y )\)</span> следующим образом:</p>
<p><span class="math notranslate nohighlight">\(
(\mu y)f(x_1, \ldots, x_k, y) = \begin{cases}z, &amp; \text{если } f(x_1, \ldots, x_k, z) = 0 \text{ и }\\ &amp; (\forall m &lt; z)(f(x_1, \ldots, x_k, m) &gt; 0), \\ \text{не определена} &amp; \text{иначе}  \end{cases}
\)</span></p>
<p>Поэтому <span class="math notranslate nohighlight">\(\mu y\)</span> - это функция, которая отображает <span class="math notranslate nohighlight">\((k+1)\)</span>-арную функцию в <span class="math notranslate nohighlight">\(k\)</span>-арную функцию. Определение указывает для любого заданного входного значения <span class="math notranslate nohighlight">\(\vec n\)</span> процесс поиска наименьшего значения <span class="math notranslate nohighlight">\(m\)</span>, такого, что <span class="math notranslate nohighlight">\(f(n, m) = 0\)</span>. Значение <span class="math notranslate nohighlight">\(((\mu y )f)(n)\)</span> не определено, если либо нет такого <span class="math notranslate nohighlight">\(m\)</span>, для которого <span class="math notranslate nohighlight">\(f(n, m) = 0\)</span>, либо если такое <span class="math notranslate nohighlight">\(m\)</span> существует, но <span class="math notranslate nohighlight">\(f(\vec n, w )\)</span> не определено для некоторого <span class="math notranslate nohighlight">\(w &lt; m\)</span>. Давайте используем <span class="math notranslate nohighlight">\(\mu_k\)</span> для определения оператора, который отображает <span class="math notranslate nohighlight">\(( k + 1)\)</span>-арную функцию функцию в <span class="math notranslate nohighlight">\(k\)</span>-арную функцию, а затем определим класс частично рекурсивных функций <span class="math notranslate nohighlight">\(\mathbf{PartRF}\)</span>, которые также называются <span class="math notranslate nohighlight">\(\mu\)</span>-рекурсивными функциями.</p>
<p><u>Определение.</u> Класс <em>частично рекурсивных функций</em> <span class="math notranslate nohighlight">\(\mathbf{PartRF}\)</span> - это наименьший подкласс частичных функций <span class="math notranslate nohighlight">\(\bigcup\limits_{k \in \mathbb N} (\mathbb N^k \mapsto \mathbb N)\)</span>, содержащий начальные функции <span class="math notranslate nohighlight">\(I_{\mathbf PR} = \{0, s, \pi_k^i \colon i, k \in \mathbf N\}\)</span>, замкнутый относительно операторов <span class="math notranslate nohighlight">\(\{Comp_k^l, PrimR_k, \mu_k \colon k, l \in \mathbb N\}\)</span>. Назовем <span class="math notranslate nohighlight">\(f \in \mathbf{PartRF}\)</span> рекурсивной функцией, если она тотальна. Класс рекурсивных функций обозначим <span class="math notranslate nohighlight">\(\mathbf {RF}\)</span>.</p>
<p>Итак, мы рассказали о развитии теории рекурсивных функций. Изучение рекурсивных функций началось с изучения логических основ математики, в частности программы Гильберта. Это сыграло решающую роль в доказательстве теорем Геделя и систематической формализации рекурсивных уравнений, которые определяют класс общих рекурсивных функций <span class="math notranslate nohighlight">\(\mathbf {GR}\)</span>, главным образом благодаря усилиям Клини.</p>
<p>С тех пор теория развивалась с акцентом на вычислимость и в настоящее время широко известна как теория вычислимости. Известный тезис Черча утверждает, что <span class="math notranslate nohighlight">\(\mathbf{GR}\)</span> и <span class="math notranslate nohighlight">\(\mathbf{RF}\)</span> эквивалентны, и Черч называет их вычислимыми функциями. Позже этот тезис был расширен до того, что теперь известно как тезис Черча-Тьюринга, который, по сути, утверждает, что класс рекурсивных функций <span class="math notranslate nohighlight">\(\mathbf{RF}\)</span> эквивалентен классу функций, определяемых в λ-исчислении, а также сравним с классом функций, вычисляемых машиной Тьюринга.</p>
</section>
<section id="id7">
<h3>Лямбда-исчисление<a class="headerlink" href="#id7" title="Link to this heading">#</a></h3>
</section>
<section id="id8">
<h3>Машины Тьюринга<a class="headerlink" href="#id8" title="Link to this heading">#</a></h3>
</section>
</section>
<section id="id9">
<h2>Логика в программировании<a class="headerlink" href="#id9" title="Link to this heading">#</a></h2>
</section>
<section id="id10">
<h2>Заключение<a class="headerlink" href="#id10" title="Link to this heading">#</a></h2>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="logic-computation.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Логика и вычисления</p>
      </div>
    </a>
    <a class="right-next"
       href="entertainment.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Развлечения</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">Введение</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">Формализация логики</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">Вычислительные модели и теории</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">Вычисления в истории цивилизации</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">Рекурсивные функции</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">Лямбда-исчисление</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">Машины Тьюринга</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">Логика в программировании</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">Заключение</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Кафедра математики и моделирования
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>